{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TeenAstro and Linux TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe how to build and use TeenAstro in the Linux and MacOS environments. If you find errors or have suggestions, please contact me through the TeenAstro group .","title":"Introduction"},{"location":"#teenastro-and-linux","text":"TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe how to build and use TeenAstro in the Linux and MacOS environments. If you find errors or have suggestions, please contact me through the TeenAstro group .","title":"TeenAstro and Linux"},{"location":"hwDesign/stepperAlternative/","text":"Summary of motor alternatives for TeenAstro Closed-loop Stepper: stepper-online.com This is a stepper motor with an internal shaft encoder. It is meant to be used with an external controller that corrects lost steps. This external controller is a discrete board (also from stepper-online) that accepts Step/Dir signals - it replaces the TMC5160. Notes: The same functionality could be provided with just Teensy and TMC5160 in Motion Controller mode, by connecting the encoder to the TMC5160. (small PCB change, software change) It could also be implemented by the DCSTEP feature of TMC5160, that monitors motor overload. (software change only) In my experience, if the motors are powerful enough and the mount is well balanced, TeenAstro never loses steps . For me closed-loop steppers do not bring significant improvements . Integrated Easy Servo Motor: stepper-online.com This is a brushless DC motor with an integrated controller that takes Step/Dir inputs. This can be much faster than a stepper , especially for large mounts. It would require hardware changes (buffers to adapt Step/Dir signals from 3.3V to 5V) and some software changes (remove 5160 configuration). Note that this controller only takes rising edge pulses, whereas the current TeenAstro code uses both rising and falling edges to reduce interrupt frequency. ODrive Micro with Brushless DC Motor: odriverobotics.com This is from a US company. It is similar in principle (but nicer in my view) to the one from stepper-online, with an additional Motion Controller, controlled by UART (Step/Dir is possible, but not recommended). This looks very good, but it is quite expensive, and it is no longer open source . It runs on a dedicated STM32 processor. In Step/Dir mode, same remarks as above. A positive side is that they have very good documentation . Motion Controller mode would require routing a UART to the Odrive board. ODesc with Brushless DC Motor: sequremall.com This is a chinese clone of ODrive, less expensive, with their early open-source firmware, no longer maintained . It might be a good alternative, although they have zero documentation (or if they have I could not find any).","title":"Choice of Motors"},{"location":"hwDesign/stepperAlternative/#summary-of-motor-alternatives-for-teenastro","text":"","title":"Summary of motor alternatives for TeenAstro"},{"location":"hwDesign/stepperAlternative/#closed-loop-stepper-stepper-onlinecom","text":"This is a stepper motor with an internal shaft encoder. It is meant to be used with an external controller that corrects lost steps. This external controller is a discrete board (also from stepper-online) that accepts Step/Dir signals - it replaces the TMC5160. Notes: The same functionality could be provided with just Teensy and TMC5160 in Motion Controller mode, by connecting the encoder to the TMC5160. (small PCB change, software change) It could also be implemented by the DCSTEP feature of TMC5160, that monitors motor overload. (software change only) In my experience, if the motors are powerful enough and the mount is well balanced, TeenAstro never loses steps . For me closed-loop steppers do not bring significant improvements .","title":"Closed-loop Stepper: stepper-online.com"},{"location":"hwDesign/stepperAlternative/#integrated-easy-servo-motor-stepper-onlinecom","text":"This is a brushless DC motor with an integrated controller that takes Step/Dir inputs. This can be much faster than a stepper , especially for large mounts. It would require hardware changes (buffers to adapt Step/Dir signals from 3.3V to 5V) and some software changes (remove 5160 configuration). Note that this controller only takes rising edge pulses, whereas the current TeenAstro code uses both rising and falling edges to reduce interrupt frequency.","title":"Integrated Easy Servo Motor: stepper-online.com"},{"location":"hwDesign/stepperAlternative/#odrive-micro-with-brushless-dc-motor-odriveroboticscom","text":"This is from a US company. It is similar in principle (but nicer in my view) to the one from stepper-online, with an additional Motion Controller, controlled by UART (Step/Dir is possible, but not recommended). This looks very good, but it is quite expensive, and it is no longer open source . It runs on a dedicated STM32 processor. In Step/Dir mode, same remarks as above. A positive side is that they have very good documentation . Motion Controller mode would require routing a UART to the Odrive board.","title":"ODrive Micro with Brushless DC Motor: odriverobotics.com"},{"location":"hwDesign/stepperAlternative/#odesc-with-brushless-dc-motor-sequremallcom","text":"This is a chinese clone of ODrive, less expensive, with their early open-source firmware, no longer maintained . It might be a good alternative, although they have zero documentation (or if they have I could not find any).","title":"ODesc with Brushless DC Motor: sequremall.com"},{"location":"linux/config/","text":"TeenAstro Flashing and Configuration Flashing To flash (download) the firmware on both processors, you can either use the TeenAstroUploader application (Windows only), or use directly the tools provided by the board manufacturers. Flashing the Main Unit through USB with the Teensy uploader The Teensy uploader , is available for Windows, MacOS and Linux. In all cases, it is possible to program the microcontrollers as standalone (when unplugged from the TeenAstro PCB) through a microUSB port. After assembly, the Teensy on the Main Unit can also be programmed using the same tools through the USB port on the front panel On Linux, you need to copy the 00-teensy.rules to the /etc/udev/rules.d folder as explained on the web site. Launch teensy , select the firmware file in HEX format, and hit the reset button on the board If the reset button is not accessible, you can also reset it by software by launching teensy_reboot . Note that teensy_reboot is installed by default when using platformio. If you don't use platformio, post a message on the TeenAstro help group. Flashing the SHC through USB and through Wifi The processor on the SHC is an ESP8266, on a board called Wemos D1 mini. It can be programmed with a tool called esptool.py, available here . First remove the Wemos board from the SHC, then use the micro USB connector to connect to your computer. Once the Wemos is programmed, it is easier to flash through the web server interface , so that there is no need to open the case. Configuration These utilities allow to view and change the configuration of the mount (motor parameters etc.) For Windows, use TeenAstroConfig.exe For Mac OSX and Linux, use TAConfig.py TAConfig version 1.2 (only works with TeenAstro firmware 1.2 and above) combines the configuration with some of the features from the web server (site management, status display)","title":"Utilities"},{"location":"linux/config/#teenastro-flashing-and-configuration","text":"","title":"TeenAstro Flashing and Configuration"},{"location":"linux/config/#flashing","text":"To flash (download) the firmware on both processors, you can either use the TeenAstroUploader application (Windows only), or use directly the tools provided by the board manufacturers.","title":"Flashing"},{"location":"linux/config/#flashing-the-main-unit-through-usb-with-the-teensy-uploader","text":"The Teensy uploader , is available for Windows, MacOS and Linux. In all cases, it is possible to program the microcontrollers as standalone (when unplugged from the TeenAstro PCB) through a microUSB port. After assembly, the Teensy on the Main Unit can also be programmed using the same tools through the USB port on the front panel On Linux, you need to copy the 00-teensy.rules to the /etc/udev/rules.d folder as explained on the web site. Launch teensy , select the firmware file in HEX format, and hit the reset button on the board If the reset button is not accessible, you can also reset it by software by launching teensy_reboot . Note that teensy_reboot is installed by default when using platformio. If you don't use platformio, post a message on the TeenAstro help group.","title":"Flashing the Main Unit through USB with the Teensy uploader"},{"location":"linux/config/#flashing-the-shc-through-usb-and-through-wifi","text":"The processor on the SHC is an ESP8266, on a board called Wemos D1 mini. It can be programmed with a tool called esptool.py, available here . First remove the Wemos board from the SHC, then use the micro USB connector to connect to your computer. Once the Wemos is programmed, it is easier to flash through the web server interface , so that there is no need to open the case.","title":"Flashing the SHC through USB and through Wifi"},{"location":"linux/config/#configuration","text":"These utilities allow to view and change the configuration of the mount (motor parameters etc.) For Windows, use TeenAstroConfig.exe For Mac OSX and Linux, use TAConfig.py TAConfig version 1.2 (only works with TeenAstro firmware 1.2 and above) combines the configuration with some of the features from the web server (site management, status display)","title":"Configuration"},{"location":"linux/ekos/","text":"TeenAstro with Ekos Ekos is documented here . This gives some detail on its operation with TeenAstro Connection options KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through Serial / USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). ** Note: ** I found that, for visual use, both methods are fine, but for astrophotography the serial port is more reliable than Wifi (especially for guiding). Another choice is which computer runs Ekos, and how it is controlled. To reduce the number of cables, I chose to run it on a Raspberry Pi 4 attached the mount dovetail. I control the Pi 4 remotely via the excellent NoMachine free remote desktop application. Goto To control remotely the mount, start Kstars, launch Ekos from the Tool menu. Click on the Mount tab. You get this screen: Click on Mount Control to set the slew speed, select a target, and move in all directions: Guiding For long exposure astrophotography, the mount must track the stars precisely. To compensate polar alignment errors and refraction effects, we need to guide, by using a guide camera and software (PHD2 or Ekos Guide Module) running on a computer to correct the mount movement. The signals can be either electrical impulsions through an ST4 cable, or software commands from computer to mount (no need for ST4 cable between camera and mount). To select the software mode, enable \"Pulse Guiding\" in the TeenAstro INDI control panel. ** As noted above, guiding is more reliable with the serial port. For the time being, don't use Wifi for guiding. ** Other important options in the Guide tab of the control panel are: - Exposure time. I use 1 or 2 seconds. - Guiding rate. I found that 0.5x works best on my setup. - Bin: 2x2 in the Guide Module tab. If you use the Ekos guide module, keep the suggested control parameters (proportional and integral gains). With these settings, in the best case (with excellent seeing) I obtain a guiding error of between 0.5 arc-second and 1 arc-second RMS with my setup (250mm focal length guide scope, ASI120mini camera, AP600 mount) PHD2 vs. Ekos internal guiding Both work. I found it easier to use the internal Ekos guiding module (no need to start an external program), but PHD2 seems more reliable and has more options. Meridian Flip All German Equatorial mounts need to switch from east to west when imaging past the meridian. This is called the Meridian Flip and Ekos provides a way to do this automatically during a session. Here are the steps: - Determine the \"Past Meridian Mount Limit\" of your mount, ie the angle it can continue tracking past the meridian without the telescope hitting the pier. - Program this limit in the mount via the handset or Wifi interface - In the Ekos mount tab, check the box \"Flip if HA>\" and enter the same value minus one degree than the TeenAstro limit. For example, if the TeenAstro limit is 10 degrees, enter 9 degrees in Ekos. Start your photo session. When Ekos detects that the next capture will get close to the limit, it initiates a GOTO to the current target. TeenAstro will perform the flip automatically. In some cases, TeenAstro decides it is not close enough, then Ekos will reschedule it after the next exposure. When the flip is done, Ekos restarts the photo session, after eventually performing an astrometry session to re-center the image (if programmed in the scheduler). ** Note ** : The current Ekos official release (January 2022) has a bug that prevents the meridian flip timer from operating. The fix is identified and should be implemented soon. Polar Alignment Ekos has a good polar alignment feature, that uses the stellar solver. It works as follows: From a given position, preferably on the meridian (but NOT from the Home position - more on this later), it takes one picture, then rotates either west or east, by 15 or 30 degrees (both options are configurable), twice, and takes 2 other pictures. From these 3 images, it computes 2 vectors that describe the errors in altitude and azimuth. Once these two errors are corrected by adjusting the mount, alignment is completed. This takes only about 5 minutes, and allows an alignment better than 30 arc-seconds. Attention : Ekos simulates E/W button presses until RA has increased/decreased by 15 or 30 degrees. But one feature of TeenAstro is that when the mount points Home (towards the pole), rotating the RA axis does not change the displayed RA value. Therefore Ekos will keep pressing the E or W button forever. Since TeenAstro does not check mount limits in this situation, the telescope will hit the pier sooner or later, and potentially damage camera, filters etc. This means you must be very careful to perform polar alignment from any position near the meridian EXCEPT from Home position Error handling When the telescope is tracking and moves past one of the defined limits, it stops tracking and does not execute any GOTO commands. On the SHC, an icon appears to show the limit. When it is controlled by Ekos, it shows the message in the Main tab of the TeenAstro INDI control panel. In both cases, the procedure to recover is the same: use the arrows (physical buttons on the SHC, or virtual buttons on Ekos) to move the mount back in the safe zone. As soon as the error message disappears, normal operation can resume. Using TeenAstro without the hand controller It is perfectly possible to use this configuration, for example in a fixed pier situation where the mount does not move between uses. The whole functionality is controlled entirely by Ekos on the remote computer. Obviously in this case only a serial connection is possible, since the Wifi module is no longer available. (It is in the SHC).","title":"Ekos"},{"location":"linux/ekos/#teenastro-with-ekos","text":"Ekos is documented here . This gives some detail on its operation with TeenAstro","title":"TeenAstro with Ekos"},{"location":"linux/ekos/#connection-options","text":"KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through Serial / USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). ** Note: ** I found that, for visual use, both methods are fine, but for astrophotography the serial port is more reliable than Wifi (especially for guiding). Another choice is which computer runs Ekos, and how it is controlled. To reduce the number of cables, I chose to run it on a Raspberry Pi 4 attached the mount dovetail. I control the Pi 4 remotely via the excellent NoMachine free remote desktop application.","title":"Connection options"},{"location":"linux/ekos/#goto","text":"To control remotely the mount, start Kstars, launch Ekos from the Tool menu. Click on the Mount tab. You get this screen: Click on Mount Control to set the slew speed, select a target, and move in all directions:","title":"Goto"},{"location":"linux/ekos/#guiding","text":"For long exposure astrophotography, the mount must track the stars precisely. To compensate polar alignment errors and refraction effects, we need to guide, by using a guide camera and software (PHD2 or Ekos Guide Module) running on a computer to correct the mount movement. The signals can be either electrical impulsions through an ST4 cable, or software commands from computer to mount (no need for ST4 cable between camera and mount). To select the software mode, enable \"Pulse Guiding\" in the TeenAstro INDI control panel. ** As noted above, guiding is more reliable with the serial port. For the time being, don't use Wifi for guiding. ** Other important options in the Guide tab of the control panel are: - Exposure time. I use 1 or 2 seconds. - Guiding rate. I found that 0.5x works best on my setup. - Bin: 2x2 in the Guide Module tab. If you use the Ekos guide module, keep the suggested control parameters (proportional and integral gains). With these settings, in the best case (with excellent seeing) I obtain a guiding error of between 0.5 arc-second and 1 arc-second RMS with my setup (250mm focal length guide scope, ASI120mini camera, AP600 mount)","title":"Guiding"},{"location":"linux/ekos/#phd2-vs-ekos-internal-guiding","text":"Both work. I found it easier to use the internal Ekos guiding module (no need to start an external program), but PHD2 seems more reliable and has more options.","title":"PHD2 vs. Ekos internal guiding"},{"location":"linux/ekos/#meridian-flip","text":"All German Equatorial mounts need to switch from east to west when imaging past the meridian. This is called the Meridian Flip and Ekos provides a way to do this automatically during a session. Here are the steps: - Determine the \"Past Meridian Mount Limit\" of your mount, ie the angle it can continue tracking past the meridian without the telescope hitting the pier. - Program this limit in the mount via the handset or Wifi interface - In the Ekos mount tab, check the box \"Flip if HA>\" and enter the same value minus one degree than the TeenAstro limit. For example, if the TeenAstro limit is 10 degrees, enter 9 degrees in Ekos. Start your photo session. When Ekos detects that the next capture will get close to the limit, it initiates a GOTO to the current target. TeenAstro will perform the flip automatically. In some cases, TeenAstro decides it is not close enough, then Ekos will reschedule it after the next exposure. When the flip is done, Ekos restarts the photo session, after eventually performing an astrometry session to re-center the image (if programmed in the scheduler). ** Note ** : The current Ekos official release (January 2022) has a bug that prevents the meridian flip timer from operating. The fix is identified and should be implemented soon.","title":"Meridian Flip"},{"location":"linux/ekos/#polar-alignment","text":"Ekos has a good polar alignment feature, that uses the stellar solver. It works as follows: From a given position, preferably on the meridian (but NOT from the Home position - more on this later), it takes one picture, then rotates either west or east, by 15 or 30 degrees (both options are configurable), twice, and takes 2 other pictures. From these 3 images, it computes 2 vectors that describe the errors in altitude and azimuth. Once these two errors are corrected by adjusting the mount, alignment is completed. This takes only about 5 minutes, and allows an alignment better than 30 arc-seconds. Attention : Ekos simulates E/W button presses until RA has increased/decreased by 15 or 30 degrees. But one feature of TeenAstro is that when the mount points Home (towards the pole), rotating the RA axis does not change the displayed RA value. Therefore Ekos will keep pressing the E or W button forever. Since TeenAstro does not check mount limits in this situation, the telescope will hit the pier sooner or later, and potentially damage camera, filters etc. This means you must be very careful to perform polar alignment from any position near the meridian EXCEPT from Home position","title":"Polar Alignment"},{"location":"linux/ekos/#error-handling","text":"When the telescope is tracking and moves past one of the defined limits, it stops tracking and does not execute any GOTO commands. On the SHC, an icon appears to show the limit. When it is controlled by Ekos, it shows the message in the Main tab of the TeenAstro INDI control panel. In both cases, the procedure to recover is the same: use the arrows (physical buttons on the SHC, or virtual buttons on Ekos) to move the mount back in the safe zone. As soon as the error message disappears, normal operation can resume.","title":"Error handling"},{"location":"linux/ekos/#using-teenastro-without-the-hand-controller","text":"It is perfectly possible to use this configuration, for example in a fixed pier situation where the mount does not move between uses. The whole functionality is controlled entirely by Ekos on the remote computer. Obviously in this case only a serial connection is possible, since the Wifi module is no longer available. (It is in the SHC).","title":"Using TeenAstro without the hand controller"},{"location":"linux/indi/","text":"Introduction to INDI The INDI Library is a collection of programs designed to control astronomical equipment. Its telescope control platform, called Ekos, controls a TeenAstro mount through an INDI driver. Driver design TeenAstro, like many other mounts, is controlled with a protocol derived from an early Meade telescope, called LX200 . The TeenAstro INDI driver derives directly from the simplest LX200 driver with basic functionality (lx200basic), and adds the TeenAstro specific functions. When available, the existing LX200 functionality is used, if not it is copied from OnStep and other drivers, or implemented from scratch. Repository: https://github.com/indilib/indi Source files : lx200_TeenAstro.cpp, lx200_TeenAstro.h Driver info: indi_lx200_TeenAstro Driver versions Date Version Description Jan 2020 0.8 Basic functionality Apr 2020 1.0 Added error handling for limits, save and restore driver configuration 1 May 2020 1.1 Fixed TCP/IP comms error, set default guide speed to 0.5x 10 May 2020 1.2 Compatibility with Firmware v1.2 (backward compatible with 1.1) Jan 2022 1.2a Fixed slew speed selection Connection options KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). Mount Type TeenAstro supports German Equatorial, Alt Azimuth, Fork Azimuth and Fork equatorial mounts. However the current driver only supports German Equatorial. Current features GOTO: yes Sync: yes Slew Speeds: Guide, Slow, Medium, Fast, Max. All speeds can be configured through the hand controller. Max speed depends on mount and motors. Track Rates: Sidereal, Solar, Lunar Tracking can be disabled Auto Meridian Flip: no Configurable custom parking positions: yes Pulse-guiding: yes Guide Rates: 0.25x, 0.5x, 1x ST4 Guiding: yes Sync and Alignment (2 or 3-star) is done using the hand controller. The mount needs to be aligned before connecting the driver. Guiding can be done with ST4 or software (pulse-guiding) 4 sites are stored, with their coordinates including altitude (elevation) An optional GPS device can be connected, its functionality is not exposed to the INDI driver. Functionality - standard Meade commands These lists are not complete, but are included here for convenience. Check the source code (Command_xx.ino) for details Function Command Used in INDI driver Get Right Ascension / Declination :GR# :GD# \u2713 Get Azimuth / Altitude :GA# :GZ# Set target RA, Declination :Sr...#, :Sd...# \u2713 Goto target RA/Dec :MS# \u2713 Set target Azimuth / Altitude :Sa...#, :Sz...# Goto target az/alt :MA# Set tracking mode :TQ# :TS# :TL# \u2713 Park / Unpark / Set parking position :HQ# :HR# :HP# \u2713 Sync to current coords/object :CS# :CM# \u2713 pier side / dist to meridian :Gm# Set centering speed (buttons) :R# \u2713 Move N / S / W / E :Mx# \u2713 Display firmware data :GVD# :GVN# etc \u2713 Get current site location, UTC etc :GM# etc. \u2713 Select Site :Wn# \u2713 Send guiding command :Mgn# etc. \u2713 Enable / Disable tracking :Te# :Td# \u2713 Enable / disable refraction correction :Tr# :Tn# Get / Set site altitude :Ge# :Se# \u2713 Functionality - TeenAstro-specific commands All Get commands (:GX..) except :GXI# have a Set (:SX..) counterpart that sets the parameter in TeenAstro Function Command Notes Used in INDI driver Get mount status :GXI# (1) \u2713 Get Acceleration :GXRA# Get Max Rate :GXRX# Get Default Rate :GXRD# Get Backlash rate :GXRB# Get Limits :GXLn# n is E/W/U/O/H Get Date/Time :GXTn# n is 0 to 2 Get Backlash values :GXMBn# n is D or R Get Gear :GXMGn# n is D or R Get Steps :GXMSn# n is D or R Get Microsteps :GXMMn# n is D or R Get Direction :GXMRn# n is D or R Get High current :GXMCn# n is D or R Get Low current :GXMcn# n is D or R Get Pole Alignment (True / Apparent) :GXApn# See Command_G.ino Get Debug info :GXDnn# See Command_G.ino Get Axis Positions in degrees :GXPn# n is 1 or 2 Get Custom Tracking Rate :GXRn# n is 0 to 4 \u2713 (1) Status is a 16-character string, coding the status as follows: position char values meaning 0 0, 1, 2 '0' + 2 * movingTo + sideralTracking 1 0, 1 sidereal mode 2 pIPF not [p]arked, parking [I]n-progress, [P]arked, Park [F]ailed 3 space or H at home 4 0 to 3 current slew rate 5 space @ G spiral, guide 6 * + * for guide pulse/ST4, + for guide recenter 7-8 > < b _ see Command_G.ino 9 f fault 10 c corrected tracking 11 0 1 star alignment 12 E K k A mount type 13 E W pier side 14 0 1 GNSS valid 15 0 to E Last error code - See LX200RETURN in TeenAstroLX200io.h Not implemented Tab Function command Standard Meade In TeenAstro Main control Object info - macro from lx200driver.h :LI# yes no Main control Alignment status :Gw# yes no Main control Elevation limits :Sh# :So# yes yes Motion control Custom track rate (RA / declination) :RA# :RE# yes no Motion control dual axis tracking :T2# no no Motion control Tracking frequency / frequency adjust :T+# :T-# :GT# yes no Align Polar align :MP# no no PEC Periodic Error Correction :QZ# etc. yes no Focuser Focus control :F+ etc. yes yes","title":"INDI driver"},{"location":"linux/indi/#introduction-to-indi","text":"The INDI Library is a collection of programs designed to control astronomical equipment. Its telescope control platform, called Ekos, controls a TeenAstro mount through an INDI driver.","title":"Introduction to INDI"},{"location":"linux/indi/#driver-design","text":"TeenAstro, like many other mounts, is controlled with a protocol derived from an early Meade telescope, called LX200 . The TeenAstro INDI driver derives directly from the simplest LX200 driver with basic functionality (lx200basic), and adds the TeenAstro specific functions. When available, the existing LX200 functionality is used, if not it is copied from OnStep and other drivers, or implemented from scratch. Repository: https://github.com/indilib/indi Source files : lx200_TeenAstro.cpp, lx200_TeenAstro.h Driver info: indi_lx200_TeenAstro","title":"Driver design"},{"location":"linux/indi/#driver-versions","text":"Date Version Description Jan 2020 0.8 Basic functionality Apr 2020 1.0 Added error handling for limits, save and restore driver configuration 1 May 2020 1.1 Fixed TCP/IP comms error, set default guide speed to 0.5x 10 May 2020 1.2 Compatibility with Firmware v1.2 (backward compatible with 1.1) Jan 2022 1.2a Fixed slew speed selection","title":"Driver versions"},{"location":"linux/indi/#connection-options","text":"KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above).","title":"Connection options"},{"location":"linux/indi/#mount-type","text":"TeenAstro supports German Equatorial, Alt Azimuth, Fork Azimuth and Fork equatorial mounts. However the current driver only supports German Equatorial.","title":"Mount Type"},{"location":"linux/indi/#current-features","text":"GOTO: yes Sync: yes Slew Speeds: Guide, Slow, Medium, Fast, Max. All speeds can be configured through the hand controller. Max speed depends on mount and motors. Track Rates: Sidereal, Solar, Lunar Tracking can be disabled Auto Meridian Flip: no Configurable custom parking positions: yes Pulse-guiding: yes Guide Rates: 0.25x, 0.5x, 1x ST4 Guiding: yes Sync and Alignment (2 or 3-star) is done using the hand controller. The mount needs to be aligned before connecting the driver. Guiding can be done with ST4 or software (pulse-guiding) 4 sites are stored, with their coordinates including altitude (elevation) An optional GPS device can be connected, its functionality is not exposed to the INDI driver.","title":"Current features"},{"location":"linux/indi/#functionality-standard-meade-commands","text":"These lists are not complete, but are included here for convenience. Check the source code (Command_xx.ino) for details Function Command Used in INDI driver Get Right Ascension / Declination :GR# :GD# \u2713 Get Azimuth / Altitude :GA# :GZ# Set target RA, Declination :Sr...#, :Sd...# \u2713 Goto target RA/Dec :MS# \u2713 Set target Azimuth / Altitude :Sa...#, :Sz...# Goto target az/alt :MA# Set tracking mode :TQ# :TS# :TL# \u2713 Park / Unpark / Set parking position :HQ# :HR# :HP# \u2713 Sync to current coords/object :CS# :CM# \u2713 pier side / dist to meridian :Gm# Set centering speed (buttons) :R# \u2713 Move N / S / W / E :Mx# \u2713 Display firmware data :GVD# :GVN# etc \u2713 Get current site location, UTC etc :GM# etc. \u2713 Select Site :Wn# \u2713 Send guiding command :Mgn# etc. \u2713 Enable / Disable tracking :Te# :Td# \u2713 Enable / disable refraction correction :Tr# :Tn# Get / Set site altitude :Ge# :Se# \u2713","title":"Functionality - standard Meade commands"},{"location":"linux/indi/#functionality-teenastro-specific-commands","text":"All Get commands (:GX..) except :GXI# have a Set (:SX..) counterpart that sets the parameter in TeenAstro Function Command Notes Used in INDI driver Get mount status :GXI# (1) \u2713 Get Acceleration :GXRA# Get Max Rate :GXRX# Get Default Rate :GXRD# Get Backlash rate :GXRB# Get Limits :GXLn# n is E/W/U/O/H Get Date/Time :GXTn# n is 0 to 2 Get Backlash values :GXMBn# n is D or R Get Gear :GXMGn# n is D or R Get Steps :GXMSn# n is D or R Get Microsteps :GXMMn# n is D or R Get Direction :GXMRn# n is D or R Get High current :GXMCn# n is D or R Get Low current :GXMcn# n is D or R Get Pole Alignment (True / Apparent) :GXApn# See Command_G.ino Get Debug info :GXDnn# See Command_G.ino Get Axis Positions in degrees :GXPn# n is 1 or 2 Get Custom Tracking Rate :GXRn# n is 0 to 4 \u2713 (1) Status is a 16-character string, coding the status as follows: position char values meaning 0 0, 1, 2 '0' + 2 * movingTo + sideralTracking 1 0, 1 sidereal mode 2 pIPF not [p]arked, parking [I]n-progress, [P]arked, Park [F]ailed 3 space or H at home 4 0 to 3 current slew rate 5 space @ G spiral, guide 6 * + * for guide pulse/ST4, + for guide recenter 7-8 > < b _ see Command_G.ino 9 f fault 10 c corrected tracking 11 0 1 star alignment 12 E K k A mount type 13 E W pier side 14 0 1 GNSS valid 15 0 to E Last error code - See LX200RETURN in TeenAstroLX200io.h","title":"Functionality - TeenAstro-specific commands"},{"location":"linux/indi/#not-implemented","text":"Tab Function command Standard Meade In TeenAstro Main control Object info - macro from lx200driver.h :LI# yes no Main control Alignment status :Gw# yes no Main control Elevation limits :Sh# :So# yes yes Motion control Custom track rate (RA / declination) :RA# :RE# yes no Motion control dual axis tracking :T2# no no Motion control Tracking frequency / frequency adjust :T+# :T-# :GT# yes no Align Polar align :MP# no no PEC Periodic Error Correction :QZ# etc. yes no Focuser Focus control :F+ etc. yes yes","title":"Not implemented"},{"location":"swDesign/SmartHandController/","text":"Smart Hand Controller The SHC handles all user interface, as well as the databases for deep-sky objects, and the solar system computations. It is currently implemented on a Wemos processor that includes a Wifi interface. The peripherals are 7 buttons, a screen controlled by I2C, and a UART connected to the Main Unit. All commands and response follow the LX200 standard, with proprietary additions.","title":"Smart Hand Controller"},{"location":"swDesign/SmartHandController/#smart-hand-controller","text":"The SHC handles all user interface, as well as the databases for deep-sky objects, and the solar system computations. It is currently implemented on a Wemos processor that includes a Wifi interface. The peripherals are 7 buttons, a screen controlled by I2C, and a UART connected to the Main Unit. All commands and response follow the LX200 standard, with proprietary additions.","title":"Smart Hand Controller"},{"location":"swDesign/TeenAstroMainUnit/","text":"TeenAstroMainUnit The current design (2023) Main Unit runs on Teensy 3.2 and Teensy 4.0 boards. These are based on ARM Cortex processor, with peripherals (UART, timer, SPI, etc.). The stepper controllers are TMC2130 or TMC2160 from Trinamic in STEP/DIR mode. The software is built with the Arduino framework (setup / loop) and consists of 3 main parts: the Main Loop, the Timer Loop and the Motor Interrupts. Without an operating system, it relies on global variables. To prevent concurrent variable accesses between the 3 contexts, it disables interrupts (cli / sei). Main Loop The Main loop runs every 10mS (sidereal). It polls for commands from both UARTs (SHC and USB), which handle identical commands based on the LX200 standard (Goto, track, guide etc) with proprietary extensions. It computes the positions and speeds of both axes, then checks for safety limits. Positioning Mode (Goto) Much of the code is common between Eq and Altaz mounts. The simplified call sequence for a Goto RA/Dec command is as follows: GotoEqu(HA, Dec) // LX200 command EquToHor(HA, Dec) // computes target Az/Alt goToHor(Az, Alt) // can also be called directly by LX200 command toInstrumentalDeg(Az, Alt) // matrix operation that computes axes positions as floating-point degrees predictTarget() // converts degrees to steps (long integers), taking into account the gear ratio Angle2InsrtAngle // corrects positions according to pier side if needed Goto(Axis1, Axis2) // check for errors, then sets targets for both axes For retrieving current RA/Dec: getEqu() // LX200 command :GR#, :GD# getHorApp() // retrieves axis positions in steps and converts to degrees toReferenceDeg() // matrix operation - converts axis degrees to sky Az/Alt HorTopoToEqu() // converts Az/Alt to HA/Dec Mapping sky coordinates to axis angles The difference between Eq and AltAz mounts is handled inside the alignment matrix operations (toInstrumentalDeg / toReferenceDeg) based on Toshimi Taki's 2004 paper . At initialization, the alignment matrix is initialized as follows: - for AltAz mounts, Axis1 is Azimuth reversed by 180\u00ba, Axis2 is Altitude, so that in the Home position the optical tube is horizontal, pointing South. - for Eq mounts, it converts Axis1/Axis2 to Altitude and Azimuth, so that in the Home position the optical tube points to the celestial pole. The idea is to perform all Goto with the same (AltAz) code. This simplifies somewhat the design, but it hides the amount of conversions going on behind the scenes (see tracking section below) Mapping axis angles to steps This mapping is not one-to-one: The same position (in steps) may represent 2 different axis angles, according to the hemisphere. This also applies to the direction of tracking. The motor reverse bit is handled at the very lowest level so that the whole software uses the same coordinates for direct and reverse directions. Slewing Mode Slewing or centering is triggered by pressing direction keys. It moves the mount at predefined speeds in any direction, without a target. This is the call sequence: MoveAxis1/2 // LX200 command MoveAxis1/2atRate (rate) // directy sets the motor timers Tracking Tracking does not use a fixed velocity for the RA axis, but repeated positioning mode on a moving pseudo-target. For an Eq mount, it goes like this: computeTrackingRate // :Te# LX200 command. This enters the tracking mode called by the main loop: do_compensation_calc() // Computes positions behind and ahead of the current position: for each position getEqu() getHorApp() // retrieves RA/Dec axis positions in steps and converts to degrees toReferenceDeg() // converts axis degrees to sky Az/Alt - matrix operation horAppToEqu() // convert Az/Alt to RA/Dec - trig operation equToHor() // convert RA/Dec to Az/Alt - trig operation toInstrumentalDeg() // convert Az/Alt to RA/Dec axis degrees - matrix operation instrtoStep() // axis degrees to steps compute difference between the 2 axis positions, derive a speed then set the motor timers Guiding Guiding for astrophoto is performed either by signals on the ST4 connector emulating button presses, or by software commands. It increases or decreases the tracking speed on both axes. The code is somewhat confusing because the term is used both for centering (SHC button presses) and for automatic guiding via software (PHD2 etc.) enableST4GuideRate() // :Mgdnnnn# Pulse guide command PerformPulseGuiding() apply_GuidingA1() // modify the tracking pseudo-target Timer Loop The timer loop is triggered by a hardware timer that runs every 10mS (sidereal). From the current mode (Goto, track, guide etc.) it computes and programs the periods (rates) for both motor interrupts. Motor Interrupts There is one motor interrupt handler for each axis motor. Each one runs at a period determined by the axis speed and controls the STEP and DIR inputs of the TMC motor controller.","title":"TeenAstroMainUnit"},{"location":"swDesign/TeenAstroMainUnit/#teenastromainunit","text":"The current design (2023) Main Unit runs on Teensy 3.2 and Teensy 4.0 boards. These are based on ARM Cortex processor, with peripherals (UART, timer, SPI, etc.). The stepper controllers are TMC2130 or TMC2160 from Trinamic in STEP/DIR mode. The software is built with the Arduino framework (setup / loop) and consists of 3 main parts: the Main Loop, the Timer Loop and the Motor Interrupts. Without an operating system, it relies on global variables. To prevent concurrent variable accesses between the 3 contexts, it disables interrupts (cli / sei).","title":"TeenAstroMainUnit"},{"location":"swDesign/TeenAstroMainUnit/#main-loop","text":"The Main loop runs every 10mS (sidereal). It polls for commands from both UARTs (SHC and USB), which handle identical commands based on the LX200 standard (Goto, track, guide etc) with proprietary extensions. It computes the positions and speeds of both axes, then checks for safety limits.","title":"Main Loop"},{"location":"swDesign/TeenAstroMainUnit/#positioning-mode-goto","text":"Much of the code is common between Eq and Altaz mounts. The simplified call sequence for a Goto RA/Dec command is as follows: GotoEqu(HA, Dec) // LX200 command EquToHor(HA, Dec) // computes target Az/Alt goToHor(Az, Alt) // can also be called directly by LX200 command toInstrumentalDeg(Az, Alt) // matrix operation that computes axes positions as floating-point degrees predictTarget() // converts degrees to steps (long integers), taking into account the gear ratio Angle2InsrtAngle // corrects positions according to pier side if needed Goto(Axis1, Axis2) // check for errors, then sets targets for both axes For retrieving current RA/Dec: getEqu() // LX200 command :GR#, :GD# getHorApp() // retrieves axis positions in steps and converts to degrees toReferenceDeg() // matrix operation - converts axis degrees to sky Az/Alt HorTopoToEqu() // converts Az/Alt to HA/Dec","title":"Positioning Mode (Goto)"},{"location":"swDesign/TeenAstroMainUnit/#mapping-sky-coordinates-to-axis-angles","text":"The difference between Eq and AltAz mounts is handled inside the alignment matrix operations (toInstrumentalDeg / toReferenceDeg) based on Toshimi Taki's 2004 paper . At initialization, the alignment matrix is initialized as follows: - for AltAz mounts, Axis1 is Azimuth reversed by 180\u00ba, Axis2 is Altitude, so that in the Home position the optical tube is horizontal, pointing South. - for Eq mounts, it converts Axis1/Axis2 to Altitude and Azimuth, so that in the Home position the optical tube points to the celestial pole. The idea is to perform all Goto with the same (AltAz) code. This simplifies somewhat the design, but it hides the amount of conversions going on behind the scenes (see tracking section below)","title":"Mapping sky coordinates to axis angles"},{"location":"swDesign/TeenAstroMainUnit/#mapping-axis-angles-to-steps","text":"This mapping is not one-to-one: The same position (in steps) may represent 2 different axis angles, according to the hemisphere. This also applies to the direction of tracking. The motor reverse bit is handled at the very lowest level so that the whole software uses the same coordinates for direct and reverse directions.","title":"Mapping axis angles to steps"},{"location":"swDesign/TeenAstroMainUnit/#slewing-mode","text":"Slewing or centering is triggered by pressing direction keys. It moves the mount at predefined speeds in any direction, without a target. This is the call sequence: MoveAxis1/2 // LX200 command MoveAxis1/2atRate (rate) // directy sets the motor timers","title":"Slewing Mode"},{"location":"swDesign/TeenAstroMainUnit/#tracking","text":"Tracking does not use a fixed velocity for the RA axis, but repeated positioning mode on a moving pseudo-target. For an Eq mount, it goes like this: computeTrackingRate // :Te# LX200 command. This enters the tracking mode called by the main loop: do_compensation_calc() // Computes positions behind and ahead of the current position: for each position getEqu() getHorApp() // retrieves RA/Dec axis positions in steps and converts to degrees toReferenceDeg() // converts axis degrees to sky Az/Alt - matrix operation horAppToEqu() // convert Az/Alt to RA/Dec - trig operation equToHor() // convert RA/Dec to Az/Alt - trig operation toInstrumentalDeg() // convert Az/Alt to RA/Dec axis degrees - matrix operation instrtoStep() // axis degrees to steps compute difference between the 2 axis positions, derive a speed then set the motor timers","title":"Tracking"},{"location":"swDesign/TeenAstroMainUnit/#guiding","text":"Guiding for astrophoto is performed either by signals on the ST4 connector emulating button presses, or by software commands. It increases or decreases the tracking speed on both axes. The code is somewhat confusing because the term is used both for centering (SHC button presses) and for automatic guiding via software (PHD2 etc.) enableST4GuideRate() // :Mgdnnnn# Pulse guide command PerformPulseGuiding() apply_GuidingA1() // modify the tracking pseudo-target","title":"Guiding"},{"location":"swDesign/TeenAstroMainUnit/#timer-loop","text":"The timer loop is triggered by a hardware timer that runs every 10mS (sidereal). From the current mode (Goto, track, guide etc.) it computes and programs the periods (rates) for both motor interrupts.","title":"Timer Loop"},{"location":"swDesign/TeenAstroMainUnit/#motor-interrupts","text":"There is one motor interrupt handler for each axis motor. Each one runs at a period determined by the axis speed and controls the STEP and DIR inputs of the TMC motor controller.","title":"Motor Interrupts"},{"location":"swDesign/UniversalMainUnit/","text":"UniversalMainUnit Introduction Here are the requirements for this redesign of the TeenAstro Main Unit. Support for multiple processors Support Step/Dir steppers, MotionControl (SPI-only) steppers, DC servo motors Encoders: on axis (absolute), on axis (relative), on worm (relative), on motor (relative) The original TeenAstro used a Teensy 3.2 processor. UniversalMainUnit supports Teensy 4.x, but also the ESP32 family. These newer processors already have ports of FreeRTOS. Operating system A real-time OS has many advantages compared to the Arduino setup/loop model, in terms of software portability and readability. FreeRTOS is the de-facto standard for this class of projects, and it is available for both ESP32 and Teensy 4. I have started this porting project on an ESP32, because it has excellent JTAG debug capability, which Teensy 4.x does not have. However it is simple to rebuild the code for both platforms with simple #ifdef statements and to test it in parallel. File Formats I have removed the funky Arduino .INO format and used standard .h headers and .cpp sources. Much of the code is unchanged, in particular the math calculations. However all low-level code that handles timers and interrupts is new. Program Structure There are now 3 main tasks (Command, Control, Monitor) plus one task for each motor driver (in Step/Drive mode) - The Command task handles communication with the 2 serial ports, and does the high-level computation of positions and speeds - The Control task contains the logic for the main states of operation (Tracking, Goto) - The Monitor task controls the limits and does general housekeeping - The Motor tasks control the motors in Step/Dir mode. (Motion Controller does not require a task since it is very simple and relies on the TMC5160 hardware logic). - The upper-level tasks do all their computations in angles (double floating point), axis positions (32-bit signed integers) and speeds, either in multiples of sidereal speed, or in steps per second (both double floating point). Equatorial vs AltAz mounts The original TeenAstroMainUnit uses alignment matrices for 2 purposes: for the sky model (mapping sky coordinates to instrument coordinates) to handle the differences between the two kinds of mounts, by considering that an Eq mount is simply an AltAz mount oriented towards the pole. For UniversalMainUnit, the alignment matrix only maps the sky coordinates to instrument coordinates, and all mount-dependent code is isolated in 2 different classes , one for each type of mount. Each class has its own goto, tracking etc. routines. This way we only test the mount type once at startup, and in most cases we no longer need to call isAltAz() or similar functions at run-time. Mapping sky coordinates to axis angles Equatorial Mounts Mapping axis positions to sky coordinates requires careful definitions. For an equatorial mount, Axis1 is the Hour Angle and Axis2 is the Declination. A GEM mount in the Home Position points to the pole, with its DEC axis vertical. From this position, the DEC axis can move either clockwise (as seen from the top), in which case it points towards the geographic east, or counterclockwise, to point to geographic west. Following Mel Bartels, the grand-daddy of telescope mount controllers , we define the home position as Axis2 = zero, the counterclockwise orientation as \"direct\" (Axis2 > 0, Pier Side=East) and the clockwise orientation as \"flipped\" (Axis2 < 0, Pier Side=West). We can now plot the following relations between axes and coordinates, for a GEM mount in the northern hemisphere. For the southern hemisphere, both plots are reversed. Note that equatorial forks are different (to be done). ha_direct = axis1+90, ha_flipped=axis1-90 dec = 90+axis2[-90..0], dec=90-axis2[0..90] AltAz Mounts For AltAz mounts, Axis1 is the azimuth and Axis2 is the altitude. Home position is defined as Alt=0, pointing away from the pole (in the Northern hemisphere: az=180\u00ba, alt=0\u00ba, in the Southern Hemisphere, az=0\u00ba, alt=0\u00ba). We define the Axis1 direction as positive for Clockwise, like the azimuth. N. Hemisphere Azimuth = (Axis1+180) mod 360 Altitude = Axis2 S. Hemisphere Azimuth = Axis1 mod 360 Altitude = Axis2 Hardware Abstraction Layer (HAL) The Arduino framework and libraries already provide most of the abstraction layer (UART, SPI etc.), but some functionality still requires #ifdef in the code. This includes: Chip-specific code chip reset programming hardware timers installing and running interrupt service routines (ISR) non-volatile memory Board-specific code Pin definitions and multiplexing other peripherals on the PCB (real-time clock) Until now, we have been inserting #ifdef statements throughout the code, which is not very readable or portable. A better solution would be an abstraction layer that encapsulates all chip and board-specific code like this: HAL.h #ifdef BOARD_240 // the current TeenAstro board #include teensy_3_2.h #include board_240.h #endif #ifdef BOARD_250 // Teensy 4 board #include teensy_4_0.h #include board_250.h #endif #ifdef BOARD_ESP32 // ESP32 board #include esp32_s3.h #include board_esp32.h #endif teensy_3_2.h #define ISR(f) void f(void) void beginTimers(void) { ... } esp32_s3.h #define ISR(f) void IRAM_ATTR f(void) hw_timer_t *timerP = NULL; void beginTimers(void) { ... } Platform-dependent code Teensy4 Time: Teensy4 has an on-chip RTC which keeps counting time when the chip is powered off, as long as the 2032 coin battery provides VBAT. Non-Volatile Memory: Teensy4 provides 1kB of emulated EEPROM, accessible through a provided library. Serial Ports: Teensy4 has 7 serial ports, of which 3 are used (SHC, USB, GPS) ESP32S3 Non-Volatile Memory: On ESP32 there is no EEPROM, but a section of RAM that emulates EEPROM, and gets written into the Flash with the EEPROM.commit() function. To keep the code compatible, the Monitor task performs a hash of the RAM (every 10 seconds or so) and commits it to Flash when a change is detected. Time: . JTAG: To use JTAG pins by default with a JLINK probe, we need to burn an Efuse (EFUSE_DIS_USB_JTAG) using the utility esptool.py. Refer to the Datasheet, section 2.6.4. Serial ports: ESP32S3 has 3 serial ports: USB: on the micro-USB port labeled USB. (and on the D+/D- pins of the B-connector of the prototype board). This is the PC connection: Serial.begin(); SHC: on the micro-USB port labeled UART. The pins are configurable at initialization: Serial0.begin(57600, SERIAL_8N1, 44, 43) GPS: The pins are configured at initialization: Serial1.begin(9600, SERIAL_8N1, 15, 16) NOTES : USB and SHC are used by default at boot time to load software and to display boot messages. To use them as standard serial ports, we need special gymnastics described in the Technical Reference Manual, Chapter 8. This gives these lines in platformio.ini: build_unflags = -D ARDUINO_USB_MODE=1 -D ARDUINO_USB_CDC_ON_BOOT=0 build_flags = -D ARDUINO_USB_MODE=0 -D ARDUINO_USB_CDC_ON_BOOT=1 Strapping Pins: Pins 0, 3, 45 and 46 have special functions at boot-time to configure the chip. If they are used for GPIO, their power-up state should be compatible with the chip functionality described in the ESP32S3 Datasheet, section 2.6. Timers The ISR running off the sidereal timer has only one purpose, which is to update the sidereal time. All other tasks run at multiples of the operating system's tick, normally one millisecond. Tracking and Guiding While tracking, the Control Task periodically computes the tracking speed. For Eq Mounts, this is currently a constant (it will eventually add components for refraction), for Altaz mounts, it is the difference between computed positions slightly before and after the current position. If required, it adds increments corresponding to guiding commands (pulse or ST4), or spiral. Sync and Alignment Synchronizing the mount, or 1-star alignment, is simply resetting the instrument coordinates to a known value (Home, or a given star). 2-star alignment consists of setting up a linear relationship between 2 sets of mount axis angles: sky coordinates corresponding to the 2 stars and instrument coordinates read from the mount. We use Toshimi Taki's matrix method, with 2 observed stars and the 3rd reference computed as an orthogonal direction to the first 2. Note: This alignment is not very useful, since it only uses one 3x3 matrix. 9 parameters are not sufficient to build a complete sky model. We would need n_point_alignment as described in the EQMOD alignment model document. As of today, I recommend using a simple 1-star synchronization with careful polar alignment. Refraction Not yet implemented Motion Control (SPI-only) mode of the 5160 stepper controller The standard TeenAstro code base uses the STEP/DIR mode for controlling the stepper motor driver (TMC2130 or TMC5160). This requires the microcontroller to toggle the STEP input of the driver for each step. Since we use microstepping to get a smooth motion, we program one interrupt for each microstep. The interrupt period is t = 24 * 3600 / (gear reduction * steps/rot * microsteps) For example, for a gear reduction of 1000 (ratio of motor axis to mount axis rotations), typical motors with 200 steps/rotation, 32 microsteps, and sidereal rate (one mount axis rotation for 24 hours), our interrupt period is: t = 24 * 3600 / (1000 * 200 * 32) = 13.5mS. At higher slew speeds, the interrupt period is reduced proportionally: at a slew speed of 100x, the period is 13.5mS / 100 = 135\u00b5S. In turn, the minimum interrupt period of the microcontroller limits the maximum slew speed. (to 675x in our example for the Teensy 3.2). The corresponding step size for the motor axis is 360\u00ba / (gear reduction * steps/rot * microsteps). In our example, the step size is 360 / (1000 * 200 * 32) = 0.000056\u00ba = 0.2\" (arc-seconds). This step size should be kept as low as possible to ensure smooth tracking and guiding. The Trinamic 5160 can run without STEP/DIR interrupts and can control the motor directly through the SPI without requiring a microcontroller interrupt at each step. Therefore we can use the highest possible microstep value (256) and the highest slew rate that the motors can handle. (We are only limited by the maximum torque). Motor API All the motor functionality is accessed through this API. The device driver for each type of motor (Step/Dir, MotionControl, Servo) implements these functions. class MotionControl { public: virtual void setCurrentPos(long); virtual void setTargetPos(long); virtual void syncPos(long); virtual void setVmax(double); virtual void setAmax(long); virtual long getCurrentPos(void); virtual long getTargetPos(void); virtual double getSpeed(void); virtual bool positionReached(void); virtual bool isMoving(void); virtual void abort(void); virtual void resetAbort(void); virtual void initStepDir(int DirPin, int StepPin, void (*isrP)(), unsigned timerId); virtual void initMc5160(TMC5160Stepper *driverP, SemaphoreHandle_t mtx, long); virtual void setRatios(long); }; For the MotionController mode, we need a 5160 BOB (Breakout Board), or a bigTreeTech 5160. The Watterott SilentStepStick cannot be used, because we need to: set SD_MODE to GND to use the internal step generator connect an external clock to the CLK input. Without this external clock, the precision is +-4%.","title":"UniversalMainUnit"},{"location":"swDesign/UniversalMainUnit/#universalmainunit","text":"","title":"UniversalMainUnit"},{"location":"swDesign/UniversalMainUnit/#introduction","text":"Here are the requirements for this redesign of the TeenAstro Main Unit. Support for multiple processors Support Step/Dir steppers, MotionControl (SPI-only) steppers, DC servo motors Encoders: on axis (absolute), on axis (relative), on worm (relative), on motor (relative) The original TeenAstro used a Teensy 3.2 processor. UniversalMainUnit supports Teensy 4.x, but also the ESP32 family. These newer processors already have ports of FreeRTOS.","title":"Introduction"},{"location":"swDesign/UniversalMainUnit/#operating-system","text":"A real-time OS has many advantages compared to the Arduino setup/loop model, in terms of software portability and readability. FreeRTOS is the de-facto standard for this class of projects, and it is available for both ESP32 and Teensy 4. I have started this porting project on an ESP32, because it has excellent JTAG debug capability, which Teensy 4.x does not have. However it is simple to rebuild the code for both platforms with simple #ifdef statements and to test it in parallel.","title":"Operating system"},{"location":"swDesign/UniversalMainUnit/#file-formats","text":"I have removed the funky Arduino .INO format and used standard .h headers and .cpp sources. Much of the code is unchanged, in particular the math calculations. However all low-level code that handles timers and interrupts is new.","title":"File Formats"},{"location":"swDesign/UniversalMainUnit/#program-structure","text":"There are now 3 main tasks (Command, Control, Monitor) plus one task for each motor driver (in Step/Drive mode) - The Command task handles communication with the 2 serial ports, and does the high-level computation of positions and speeds - The Control task contains the logic for the main states of operation (Tracking, Goto) - The Monitor task controls the limits and does general housekeeping - The Motor tasks control the motors in Step/Dir mode. (Motion Controller does not require a task since it is very simple and relies on the TMC5160 hardware logic). - The upper-level tasks do all their computations in angles (double floating point), axis positions (32-bit signed integers) and speeds, either in multiples of sidereal speed, or in steps per second (both double floating point).","title":"Program Structure"},{"location":"swDesign/UniversalMainUnit/#equatorial-vs-altaz-mounts","text":"The original TeenAstroMainUnit uses alignment matrices for 2 purposes: for the sky model (mapping sky coordinates to instrument coordinates) to handle the differences between the two kinds of mounts, by considering that an Eq mount is simply an AltAz mount oriented towards the pole. For UniversalMainUnit, the alignment matrix only maps the sky coordinates to instrument coordinates, and all mount-dependent code is isolated in 2 different classes , one for each type of mount. Each class has its own goto, tracking etc. routines. This way we only test the mount type once at startup, and in most cases we no longer need to call isAltAz() or similar functions at run-time.","title":"Equatorial vs AltAz mounts"},{"location":"swDesign/UniversalMainUnit/#mapping-sky-coordinates-to-axis-angles","text":"","title":"Mapping sky coordinates to axis angles"},{"location":"swDesign/UniversalMainUnit/#equatorial-mounts","text":"Mapping axis positions to sky coordinates requires careful definitions. For an equatorial mount, Axis1 is the Hour Angle and Axis2 is the Declination. A GEM mount in the Home Position points to the pole, with its DEC axis vertical. From this position, the DEC axis can move either clockwise (as seen from the top), in which case it points towards the geographic east, or counterclockwise, to point to geographic west. Following Mel Bartels, the grand-daddy of telescope mount controllers , we define the home position as Axis2 = zero, the counterclockwise orientation as \"direct\" (Axis2 > 0, Pier Side=East) and the clockwise orientation as \"flipped\" (Axis2 < 0, Pier Side=West). We can now plot the following relations between axes and coordinates, for a GEM mount in the northern hemisphere. For the southern hemisphere, both plots are reversed. Note that equatorial forks are different (to be done). ha_direct = axis1+90, ha_flipped=axis1-90 dec = 90+axis2[-90..0], dec=90-axis2[0..90]","title":"Equatorial Mounts"},{"location":"swDesign/UniversalMainUnit/#altaz-mounts","text":"For AltAz mounts, Axis1 is the azimuth and Axis2 is the altitude. Home position is defined as Alt=0, pointing away from the pole (in the Northern hemisphere: az=180\u00ba, alt=0\u00ba, in the Southern Hemisphere, az=0\u00ba, alt=0\u00ba). We define the Axis1 direction as positive for Clockwise, like the azimuth. N. Hemisphere Azimuth = (Axis1+180) mod 360 Altitude = Axis2 S. Hemisphere Azimuth = Axis1 mod 360 Altitude = Axis2","title":"AltAz Mounts"},{"location":"swDesign/UniversalMainUnit/#hardware-abstraction-layer-hal","text":"The Arduino framework and libraries already provide most of the abstraction layer (UART, SPI etc.), but some functionality still requires #ifdef in the code. This includes: Chip-specific code chip reset programming hardware timers installing and running interrupt service routines (ISR) non-volatile memory Board-specific code Pin definitions and multiplexing other peripherals on the PCB (real-time clock) Until now, we have been inserting #ifdef statements throughout the code, which is not very readable or portable. A better solution would be an abstraction layer that encapsulates all chip and board-specific code like this: HAL.h #ifdef BOARD_240 // the current TeenAstro board #include teensy_3_2.h #include board_240.h #endif #ifdef BOARD_250 // Teensy 4 board #include teensy_4_0.h #include board_250.h #endif #ifdef BOARD_ESP32 // ESP32 board #include esp32_s3.h #include board_esp32.h #endif teensy_3_2.h #define ISR(f) void f(void) void beginTimers(void) { ... } esp32_s3.h #define ISR(f) void IRAM_ATTR f(void) hw_timer_t *timerP = NULL; void beginTimers(void) { ... }","title":"Hardware Abstraction Layer (HAL)"},{"location":"swDesign/UniversalMainUnit/#platform-dependent-code","text":"","title":"Platform-dependent code"},{"location":"swDesign/UniversalMainUnit/#teensy4","text":"Time: Teensy4 has an on-chip RTC which keeps counting time when the chip is powered off, as long as the 2032 coin battery provides VBAT. Non-Volatile Memory: Teensy4 provides 1kB of emulated EEPROM, accessible through a provided library. Serial Ports: Teensy4 has 7 serial ports, of which 3 are used (SHC, USB, GPS)","title":"Teensy4"},{"location":"swDesign/UniversalMainUnit/#esp32s3","text":"Non-Volatile Memory: On ESP32 there is no EEPROM, but a section of RAM that emulates EEPROM, and gets written into the Flash with the EEPROM.commit() function. To keep the code compatible, the Monitor task performs a hash of the RAM (every 10 seconds or so) and commits it to Flash when a change is detected. Time: . JTAG: To use JTAG pins by default with a JLINK probe, we need to burn an Efuse (EFUSE_DIS_USB_JTAG) using the utility esptool.py. Refer to the Datasheet, section 2.6.4. Serial ports: ESP32S3 has 3 serial ports: USB: on the micro-USB port labeled USB. (and on the D+/D- pins of the B-connector of the prototype board). This is the PC connection: Serial.begin(); SHC: on the micro-USB port labeled UART. The pins are configurable at initialization: Serial0.begin(57600, SERIAL_8N1, 44, 43) GPS: The pins are configured at initialization: Serial1.begin(9600, SERIAL_8N1, 15, 16) NOTES : USB and SHC are used by default at boot time to load software and to display boot messages. To use them as standard serial ports, we need special gymnastics described in the Technical Reference Manual, Chapter 8. This gives these lines in platformio.ini: build_unflags = -D ARDUINO_USB_MODE=1 -D ARDUINO_USB_CDC_ON_BOOT=0 build_flags = -D ARDUINO_USB_MODE=0 -D ARDUINO_USB_CDC_ON_BOOT=1 Strapping Pins: Pins 0, 3, 45 and 46 have special functions at boot-time to configure the chip. If they are used for GPIO, their power-up state should be compatible with the chip functionality described in the ESP32S3 Datasheet, section 2.6.","title":"ESP32S3"},{"location":"swDesign/UniversalMainUnit/#timers","text":"The ISR running off the sidereal timer has only one purpose, which is to update the sidereal time. All other tasks run at multiples of the operating system's tick, normally one millisecond.","title":"Timers"},{"location":"swDesign/UniversalMainUnit/#tracking-and-guiding","text":"While tracking, the Control Task periodically computes the tracking speed. For Eq Mounts, this is currently a constant (it will eventually add components for refraction), for Altaz mounts, it is the difference between computed positions slightly before and after the current position. If required, it adds increments corresponding to guiding commands (pulse or ST4), or spiral.","title":"Tracking and Guiding"},{"location":"swDesign/UniversalMainUnit/#sync-and-alignment","text":"Synchronizing the mount, or 1-star alignment, is simply resetting the instrument coordinates to a known value (Home, or a given star). 2-star alignment consists of setting up a linear relationship between 2 sets of mount axis angles: sky coordinates corresponding to the 2 stars and instrument coordinates read from the mount. We use Toshimi Taki's matrix method, with 2 observed stars and the 3rd reference computed as an orthogonal direction to the first 2. Note: This alignment is not very useful, since it only uses one 3x3 matrix. 9 parameters are not sufficient to build a complete sky model. We would need n_point_alignment as described in the EQMOD alignment model document. As of today, I recommend using a simple 1-star synchronization with careful polar alignment.","title":"Sync and Alignment"},{"location":"swDesign/UniversalMainUnit/#refraction","text":"Not yet implemented","title":"Refraction"},{"location":"swDesign/UniversalMainUnit/#motion-control-spi-only-mode-of-the-5160-stepper-controller","text":"The standard TeenAstro code base uses the STEP/DIR mode for controlling the stepper motor driver (TMC2130 or TMC5160). This requires the microcontroller to toggle the STEP input of the driver for each step. Since we use microstepping to get a smooth motion, we program one interrupt for each microstep. The interrupt period is t = 24 * 3600 / (gear reduction * steps/rot * microsteps) For example, for a gear reduction of 1000 (ratio of motor axis to mount axis rotations), typical motors with 200 steps/rotation, 32 microsteps, and sidereal rate (one mount axis rotation for 24 hours), our interrupt period is: t = 24 * 3600 / (1000 * 200 * 32) = 13.5mS. At higher slew speeds, the interrupt period is reduced proportionally: at a slew speed of 100x, the period is 13.5mS / 100 = 135\u00b5S. In turn, the minimum interrupt period of the microcontroller limits the maximum slew speed. (to 675x in our example for the Teensy 3.2). The corresponding step size for the motor axis is 360\u00ba / (gear reduction * steps/rot * microsteps). In our example, the step size is 360 / (1000 * 200 * 32) = 0.000056\u00ba = 0.2\" (arc-seconds). This step size should be kept as low as possible to ensure smooth tracking and guiding. The Trinamic 5160 can run without STEP/DIR interrupts and can control the motor directly through the SPI without requiring a microcontroller interrupt at each step. Therefore we can use the highest possible microstep value (256) and the highest slew rate that the motors can handle. (We are only limited by the maximum torque).","title":"Motion Control (SPI-only) mode of the 5160 stepper controller"},{"location":"swDesign/UniversalMainUnit/#motor-api","text":"All the motor functionality is accessed through this API. The device driver for each type of motor (Step/Dir, MotionControl, Servo) implements these functions. class MotionControl { public: virtual void setCurrentPos(long); virtual void setTargetPos(long); virtual void syncPos(long); virtual void setVmax(double); virtual void setAmax(long); virtual long getCurrentPos(void); virtual long getTargetPos(void); virtual double getSpeed(void); virtual bool positionReached(void); virtual bool isMoving(void); virtual void abort(void); virtual void resetAbort(void); virtual void initStepDir(int DirPin, int StepPin, void (*isrP)(), unsigned timerId); virtual void initMc5160(TMC5160Stepper *driverP, SemaphoreHandle_t mtx, long); virtual void setRatios(long); }; For the MotionController mode, we need a 5160 BOB (Breakout Board), or a bigTreeTech 5160. The Watterott SilentStepStick cannot be used, because we need to: set SD_MODE to GND to use the internal step generator connect an external clock to the CLK input. Without this external clock, the precision is +-4%.","title":"Motor API"},{"location":"swDesign/firmware/","text":"TeenAstro Firmware Build The code is maintained on github . It consists of sources in the Arduino framework, used to build the firmware for the 3 processors in the system: - Main Unit (Teensy 3.2 / Teensy 4.0) - Focuser (Teensy 3.2) - Smart Hand Controller (ESP8266 Wemos) The recommended build environment is now PlatformIO . It is easy to install, takes care of compiler installations, Arduino framework, and works identically on Windows, OSX and Linux. PlatformIO can be used either standalone from the command line, or it can be integrated into an IDE such as VSCode. PlatformIO build For each build, PlatformIO uses a configuration file called platformio.ini , located at the root of the project. This file describes the processor, framework, and directories for sources and libraries. To build from the command line, just type pio run from the project root, and all targets are automatically rebuilt. The executables are located in directory ./pio/target_name For example, the Main Unit executable for board 240, with 5160 stepper driver is at TeenAstro/TeenAstroMainUnit/pio/240_5160 ; PlatformIO Project Configuration File for TeenAstro Main Unit ; ; Defines the different board combinations [platformio] ; Uncomment this line to build just one version, comment it to build all default_envs = 240_5160 lib_dir = ../libraries src_dir = . build_dir = pio [env] platform = teensy framework = arduino extra_scripts = pre:rename_mu.py ; Release version number - used by rename_xx.py for renaming the executable custom_option1 = 122 [env:220] board = teensy31 build_flags = -DVERSION=220 [env:230] board = teensy31 build_flags = -DVERSION=230 [env:240_2130] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=2 [env:240_5160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=3 [env:240_2160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=4 [env:250_5160] board = teensy40 build_flags = -DVERSION=250 -DAxisDriver=3 Uploading the firmware For the main unit, use platformio: type pio run -t upload For the SHC, upload with Wifi interface","title":"Building the Firmware"},{"location":"swDesign/firmware/#teenastro-firmware-build","text":"The code is maintained on github . It consists of sources in the Arduino framework, used to build the firmware for the 3 processors in the system: - Main Unit (Teensy 3.2 / Teensy 4.0) - Focuser (Teensy 3.2) - Smart Hand Controller (ESP8266 Wemos) The recommended build environment is now PlatformIO . It is easy to install, takes care of compiler installations, Arduino framework, and works identically on Windows, OSX and Linux. PlatformIO can be used either standalone from the command line, or it can be integrated into an IDE such as VSCode.","title":"TeenAstro Firmware Build"},{"location":"swDesign/firmware/#platformio-build","text":"For each build, PlatformIO uses a configuration file called platformio.ini , located at the root of the project. This file describes the processor, framework, and directories for sources and libraries. To build from the command line, just type pio run from the project root, and all targets are automatically rebuilt. The executables are located in directory ./pio/target_name For example, the Main Unit executable for board 240, with 5160 stepper driver is at TeenAstro/TeenAstroMainUnit/pio/240_5160 ; PlatformIO Project Configuration File for TeenAstro Main Unit ; ; Defines the different board combinations [platformio] ; Uncomment this line to build just one version, comment it to build all default_envs = 240_5160 lib_dir = ../libraries src_dir = . build_dir = pio [env] platform = teensy framework = arduino extra_scripts = pre:rename_mu.py ; Release version number - used by rename_xx.py for renaming the executable custom_option1 = 122 [env:220] board = teensy31 build_flags = -DVERSION=220 [env:230] board = teensy31 build_flags = -DVERSION=230 [env:240_2130] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=2 [env:240_5160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=3 [env:240_2160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=4 [env:250_5160] board = teensy40 build_flags = -DVERSION=250 -DAxisDriver=3","title":"PlatformIO build"},{"location":"swDesign/firmware/#uploading-the-firmware","text":"For the main unit, use platformio: type pio run -t upload For the SHC, upload with Wifi interface","title":"Uploading the firmware"},{"location":"swDesign/mountDesign/","text":"Primer on Mount Design To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal Advantages of each type Equatorial vs Alt-Az Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az. Fork vs. Offset tube Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts. What it means for the mount firmware The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"Supported Mounts"},{"location":"swDesign/mountDesign/#primer-on-mount-design","text":"To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal","title":"Primer on Mount Design"},{"location":"swDesign/mountDesign/#advantages-of-each-type","text":"","title":"Advantages of each type"},{"location":"swDesign/mountDesign/#equatorial-vs-alt-az","text":"Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az.","title":"Equatorial vs Alt-Az"},{"location":"swDesign/mountDesign/#fork-vs-offset-tube","text":"Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts.","title":"Fork vs. Offset tube"},{"location":"swDesign/mountDesign/#what-it-means-for-the-mount-firmware","text":"The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"What it means for the mount firmware"},{"location":"swDesign/troubleshooting/","text":"Troubleshooting This section describes common problems and how to fix them. Mount goes in the wrong direction Check that RA and DEC cables are connected correctly, change the direction of either axis in the SHC \"Mount\" menu. In general, set the mount to its Home position (using the clutches) before switching it on. Make sure the pier side reported by TeenAstro corresponds to the actual mount position. If not, it can be changed through the SHC menu, and synchronize to an object afterwards. High-pitched noise from motors Either the mount movement is blocked, or your slewing speed is too high for the motor / voltage combination Mount goes into altitude error when it should not Check your site latitude and longitude. Mount stops tracking Check altitude / meridian limits (icons on SHC) Connecting to the Main Unit through telnet or serial port To diagnose communication problems, especially with astronomy software running on a PC, it is convenient to connect to the main unit via telnet: telnet <IP address> 9999 or via the serial port / USB: cu -p /dev/ttyACM0 You can retrieve the IP address of TeenAstro on the SHC menu. Once connected, you can issue any LX200 command and view the result. For example, the standard command :GR# returns the current Right Ascension. telnet 192.168.0.12 9999 Trying 192.168.0.12... Connected to 192.168.0.12. Escape character is '^]'. :GR# 16:14:05# When connecting via telnet, the Wifi connection mode must be set to \"One to One\" (SHC Wifi menu). Check the list of commands supported by TeenAstro at this address","title":"Troubleshooting"},{"location":"swDesign/troubleshooting/#troubleshooting","text":"This section describes common problems and how to fix them.","title":"Troubleshooting"},{"location":"swDesign/troubleshooting/#mount-goes-in-the-wrong-direction","text":"Check that RA and DEC cables are connected correctly, change the direction of either axis in the SHC \"Mount\" menu. In general, set the mount to its Home position (using the clutches) before switching it on. Make sure the pier side reported by TeenAstro corresponds to the actual mount position. If not, it can be changed through the SHC menu, and synchronize to an object afterwards.","title":"Mount goes in the wrong direction"},{"location":"swDesign/troubleshooting/#high-pitched-noise-from-motors","text":"Either the mount movement is blocked, or your slewing speed is too high for the motor / voltage combination","title":"High-pitched noise from motors"},{"location":"swDesign/troubleshooting/#mount-goes-into-altitude-error-when-it-should-not","text":"Check your site latitude and longitude.","title":"Mount goes into altitude error when it should not"},{"location":"swDesign/troubleshooting/#mount-stops-tracking","text":"Check altitude / meridian limits (icons on SHC)","title":"Mount stops tracking"},{"location":"swDesign/troubleshooting/#connecting-to-the-main-unit-through-telnet-or-serial-port","text":"To diagnose communication problems, especially with astronomy software running on a PC, it is convenient to connect to the main unit via telnet: telnet <IP address> 9999 or via the serial port / USB: cu -p /dev/ttyACM0 You can retrieve the IP address of TeenAstro on the SHC menu. Once connected, you can issue any LX200 command and view the result. For example, the standard command :GR# returns the current Right Ascension. telnet 192.168.0.12 9999 Trying 192.168.0.12... Connected to 192.168.0.12. Escape character is '^]'. :GR# 16:14:05# When connecting via telnet, the Wifi connection mode must be set to \"One to One\" (SHC Wifi menu). Check the list of commands supported by TeenAstro at this address","title":"Connecting to the Main Unit through telnet or serial port"},{"location":"testing/auto_test/","text":"autoTest autoTest allows testing a TeenAstro Main Unit without the mount, by counting steps reported during specified movements. The computer is connected to the Main Unit either through the serial USB port or through TCP/IP via the Smart Hand Controller. It has 3 test options: Pointing Accuracy Test The mount points to a list of positions defined as alt-az pairs. The mount position is displayed on an altazimuth graph. At each position, the program compares Alt-Az computed from the RA / Dec reported by TeenAstro against values computed from the axis positions using Skyfield. Drift Test The mount is set to track any point in the sky. At regular intervals, the program reads the axis positions and computes the differences in RA and Dec since the test started. This can be used to verify slow movements like guiding and custom tracking. The + and - keys allow zooming in and out. The current drift averaged over the last 10 seconds is displayed on the right. Alignment Test The current TeenAstro position is plotted on top of a simple star map. A set of controls sets \"home position\" and \"pole alignment\" errors. This allows running the alignment routine in the hand controller, to view its effect on pointing accuracy.","title":"autoTest"},{"location":"testing/auto_test/#autotest","text":"autoTest allows testing a TeenAstro Main Unit without the mount, by counting steps reported during specified movements. The computer is connected to the Main Unit either through the serial USB port or through TCP/IP via the Smart Hand Controller. It has 3 test options:","title":"autoTest"},{"location":"testing/auto_test/#pointing-accuracy-test","text":"The mount points to a list of positions defined as alt-az pairs. The mount position is displayed on an altazimuth graph. At each position, the program compares Alt-Az computed from the RA / Dec reported by TeenAstro against values computed from the axis positions using Skyfield.","title":"Pointing Accuracy Test"},{"location":"testing/auto_test/#drift-test","text":"The mount is set to track any point in the sky. At regular intervals, the program reads the axis positions and computes the differences in RA and Dec since the test started. This can be used to verify slow movements like guiding and custom tracking. The + and - keys allow zooming in and out. The current drift averaged over the last 10 seconds is displayed on the right.","title":"Drift Test"},{"location":"testing/auto_test/#alignment-test","text":"The current TeenAstro position is plotted on top of a simple star map. A set of controls sets \"home position\" and \"pole alignment\" errors. This allows running the alignment routine in the hand controller, to view its effect on pointing accuracy.","title":"Alignment Test"},{"location":"testing/mount_sim/","text":"Mount Simulator mountSim is a Python program that connects to a TeenAstro through Wifi and displays a simulated mount. It reads the steps on both axes, and shows the mount's movements, including Meridian Flip (for German Equatorials only) which can help debugging eventual firmware problems. Installation Download the python scripts and STL files from Github. Install Python 3.8 or higher, and the following modules: pip install argparse numpy trimesh glooey pyglet threading serial serial.tools time datetime Launch mountSim from the command line. The single option is the IP address of your TeenAstro. python mountSim.py --ip 192.168.0.21 A graphic window opens, that displays a simplified mount model, selected according to your type of mount: You can now move the mount with the hand controller. It is also possible to control TeenAstro remotely, either with the Web interface from the SHC, or through a program running on your PC (Ekos, SkySafari etc.). Note that you can have only one Wifi (IP) port at a time, so the PC program should use USB, not Wifi. You can run mountSim in parallel with your mount, or without. In this case it is possible to speed up the maximum speed up to 2000x or more. (You may need to lower the gear reduction). Use these mouse movements: left-click+drag to change the view orientation, middle-click+drag to pan around. Program Design The program consists of 2 python scripts (mountSim.py and teenastro.py) and STL files that represent the parts of each mount. I used the 3d parametric CAD tool SolveSpace to design the mounts. The display itself is done by the trimesh library and a pyglet viewer.","title":"Mount Simulator"},{"location":"testing/mount_sim/#mount-simulator","text":"mountSim is a Python program that connects to a TeenAstro through Wifi and displays a simulated mount. It reads the steps on both axes, and shows the mount's movements, including Meridian Flip (for German Equatorials only) which can help debugging eventual firmware problems.","title":"Mount Simulator"},{"location":"testing/mount_sim/#installation","text":"Download the python scripts and STL files from Github. Install Python 3.8 or higher, and the following modules: pip install argparse numpy trimesh glooey pyglet threading serial serial.tools time datetime Launch mountSim from the command line. The single option is the IP address of your TeenAstro. python mountSim.py --ip 192.168.0.21 A graphic window opens, that displays a simplified mount model, selected according to your type of mount: You can now move the mount with the hand controller. It is also possible to control TeenAstro remotely, either with the Web interface from the SHC, or through a program running on your PC (Ekos, SkySafari etc.). Note that you can have only one Wifi (IP) port at a time, so the PC program should use USB, not Wifi. You can run mountSim in parallel with your mount, or without. In this case it is possible to speed up the maximum speed up to 2000x or more. (You may need to lower the gear reduction). Use these mouse movements: left-click+drag to change the view orientation, middle-click+drag to pan around.","title":"Installation"},{"location":"testing/mount_sim/#program-design","text":"The program consists of 2 python scripts (mountSim.py and teenastro.py) and STL files that represent the parts of each mount. I used the 3d parametric CAD tool SolveSpace to design the mounts. The display itself is done by the trimesh library and a pyglet viewer.","title":"Program Design"},{"location":"testing/teenastro_debug/","text":"Introduction This describes the platforms and tools for debugging the TeenAstro Main Unit software. Debugging platforms The simplest debug platform is a stand-alone processor like this Teensy4.1. I added a LED to display the error status, useful for testing limits. Obviously this is limited to simulation with Step/Dir drivers, since the SPI mode needs functioning TMC5160 hardware to read the motor positions. An ESP32 with a breadboard adds JTAG (see below) and the capability of driving motors through 5160 BOB. An SHC can be connected to the serial port. Debug tools The ESP32 has JTAG support, which, together with a J-Link probe, allows the use of a full-featured debugger like VSCode. I can set breakpoints, watch variables and memory. For tracing communications on serial ports between components (main unit, SHC, focuser etc.), a small logic analyzer like a Saleae (or clone) is very useful. Here the logic analyzer is setup to show UART activity in both directions. This trace is obtained during a 1 second \"West\" guiding command with the StepDir driver. The RA motor Step frequency is increased. Finally, an oscilloscope can be used for tracing low-level issues.","title":"Debugging"},{"location":"testing/teenastro_debug/#introduction","text":"This describes the platforms and tools for debugging the TeenAstro Main Unit software.","title":"Introduction"},{"location":"testing/teenastro_debug/#debugging-platforms","text":"The simplest debug platform is a stand-alone processor like this Teensy4.1. I added a LED to display the error status, useful for testing limits. Obviously this is limited to simulation with Step/Dir drivers, since the SPI mode needs functioning TMC5160 hardware to read the motor positions. An ESP32 with a breadboard adds JTAG (see below) and the capability of driving motors through 5160 BOB. An SHC can be connected to the serial port.","title":"Debugging platforms"},{"location":"testing/teenastro_debug/#debug-tools","text":"The ESP32 has JTAG support, which, together with a J-Link probe, allows the use of a full-featured debugger like VSCode. I can set breakpoints, watch variables and memory. For tracing communications on serial ports between components (main unit, SHC, focuser etc.), a small logic analyzer like a Saleae (or clone) is very useful. Here the logic analyzer is setup to show UART activity in both directions. This trace is obtained during a 1 second \"West\" guiding command with the StepDir driver. The RA motor Step frequency is increased. Finally, an oscilloscope can be used for tracing low-level issues.","title":"Debug tools"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TeenAstro and Linux TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe how to build and use TeenAstro in the Linux and MacOS environments. If you find errors or have suggestions, please contact me through the TeenAstro group .","title":"Home"},{"location":"#teenastro-and-linux","text":"TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe how to build and use TeenAstro in the Linux and MacOS environments. If you find errors or have suggestions, please contact me through the TeenAstro group .","title":"TeenAstro and Linux"},{"location":"config/","text":"TeenAstro Flashing and Configuration Flashing To flash (download) the firmware on both processors, you can either use the TeenAstroUploader application (Windows only), or use directly the tools provided by the board manufacturers. Flashing the Main Unit through USB with the Teensy uploader The Teensy uploader , is available for Windows, MacOS and Linux. In all cases, it is possible to program the microcontrollers as standalone (when unplugged from the TeenAstro PCB) through a microUSB port. After assembly, the Teensy on the Main Unit can also be programmed using the same tools through the USB port on the front panel On Linux, you need to copy the 00-teensy.rules to the /etc/udev/rules.d folder as explained on the web site. Launch teensy , select the firmware file in HEX format, and hit the reset button on the board If the reset button is not accessible, you can also reset it by software by launching teensy_reboot . Note that teensy_reboot is installed by default when using platformio. If you don't use platformio, post a message on the TeenAstro help group. Flashing the SHC through USB and through Wifi The processor on the SHC is an ESP8266, on a board called Wemos D1 mini. It can be programmed with a tool called esptool.py, available here . First remove the Wemos board from the SHC, then use the micro USB connector to connect to your computer. Once the Wemos is programmed, it is easier to flash through the web server interface , so that there is no need to open the case. Configuration These utilities allow to view and change the configuration of the mount (motor parameters etc.) For Windows, use TeenAstroConfig.exe For Mac OSX and Linux, use TAConfig.py TAConfig version 1.2 (only works with TeenAstro firmware 1.2 and above) combines the configuration with some of the features from the web server (site management, status display)","title":"Utilities"},{"location":"config/#teenastro-flashing-and-configuration","text":"","title":"TeenAstro Flashing and Configuration"},{"location":"config/#flashing","text":"To flash (download) the firmware on both processors, you can either use the TeenAstroUploader application (Windows only), or use directly the tools provided by the board manufacturers.","title":"Flashing"},{"location":"config/#flashing-the-main-unit-through-usb-with-the-teensy-uploader","text":"The Teensy uploader , is available for Windows, MacOS and Linux. In all cases, it is possible to program the microcontrollers as standalone (when unplugged from the TeenAstro PCB) through a microUSB port. After assembly, the Teensy on the Main Unit can also be programmed using the same tools through the USB port on the front panel On Linux, you need to copy the 00-teensy.rules to the /etc/udev/rules.d folder as explained on the web site. Launch teensy , select the firmware file in HEX format, and hit the reset button on the board If the reset button is not accessible, you can also reset it by software by launching teensy_reboot . Note that teensy_reboot is installed by default when using platformio. If you don't use platformio, post a message on the TeenAstro help group.","title":"Flashing the Main Unit through USB with the Teensy uploader"},{"location":"config/#flashing-the-shc-through-usb-and-through-wifi","text":"The processor on the SHC is an ESP8266, on a board called Wemos D1 mini. It can be programmed with a tool called esptool.py, available here . First remove the Wemos board from the SHC, then use the micro USB connector to connect to your computer. Once the Wemos is programmed, it is easier to flash through the web server interface , so that there is no need to open the case.","title":"Flashing the SHC through USB and through Wifi"},{"location":"config/#configuration","text":"These utilities allow to view and change the configuration of the mount (motor parameters etc.) For Windows, use TeenAstroConfig.exe For Mac OSX and Linux, use TAConfig.py TAConfig version 1.2 (only works with TeenAstro firmware 1.2 and above) combines the configuration with some of the features from the web server (site management, status display)","title":"Configuration"},{"location":"ekos/","text":"TeenAstro with Ekos Ekos is documented here . This gives some detail on its operation with TeenAstro Connection options KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through Serial / USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). Note: I found that, for visual use, both methods are fine, but for astrophotography the serial port is more reliable than Wifi (especially for guiding). Another choice is which computer runs Ekos, and how it is controlled. To reduce the number of cables, I chose to run it on a Raspberry Pi 4 attached the mount dovetail. I control the Pi 4 remotely via the excellent NoMachine free remote desktop application. Goto To control remotely the mount, start Kstars, launch Ekos from the Tool menu. Click on the Mount tab. You get this screen: Click on Mount Control to set the slew speed, select a target, and move in all directions: Guiding For long exposure astrophotography, the mount must track the stars precisely. To compensate polar alignment errors and refraction effects, we need to guide, by using a guide camera and software (PHD2 or Ekos Guide Module) running on a computer to correct the mount movement. The signals can be either electrical impulsions through an ST4 cable, or software commands from computer to mount (no need for ST4 cable between camera and mount). To select the software mode, enable \"Pulse Guiding\" in the TeenAstro INDI control panel. As noted above, guiding is more reliable with the serial port. For the time being, don't use Wifi for guiding. Other important options in the Guide tab of the control panel are: - Exposure time. I use 1 or 2 seconds. - Guiding rate. I found that 0.5x works best on my setup. - Bin: 2x2 in the Guide Module tab. If you use the Ekos guide module, keep the suggested control parameters (proportional and integral gains). With these settings, in the best case (with excellent seeing) I obtain a guiding error of between 0.5 arc-second and 1 arc-second RMS with my setup (250mm focal length guide scope, ASI120mini camera, AP600 mount) PHD2 vs. Ekos internal guiding Both work. I did not notice significant differences in precision, but I found it easier to use the internal Ekos guiding module (no need to start an external program). Meridian Flip All German Equatorial mounts need to switch from east to west when imaging past the meridian. This is called the Meridian Flip and Ekos provides a way to do this automatically during a session. Here are the steps: - Determine the \"Past Meridian Mount Limit\" of your mount, ie the angle it can continue tracking past the meridian without the telescope hitting the pier. - Program this limit in the mount via the handset or Wifi interface - In the Ekos mount tab, check the box \"Flip if HA>\" and enter the same value minus one degree than the TeenAstro limit. For example, if the TeenAstro limit is 10 degrees, enter 9 degrees in Ekos. Start your photo session. When Ekos detects that the next capture will get close to the limit, it initiates a GOTO to the current target. TeenAstro will perform the flip automatically. In some cases, TeenAstro decides it is not close enough, then Ekos will reschedule it after the next exposure. When the flip is done, Ekos restarts the photo session, after eventually performing an astrometry session to re-center the image (if programmed in the scheduler). Note : The current Ekos official release (January 2022) has a bug that prevents the meridian flip timer from operating. The fix is identified and should be implemented soon. Polar Alignment Ekos has a good polar alignment feature, that uses the stellar solver. It works as follows: From a given position, preferably on the meridian (but NOT from the Home position - more on this later), it takes one picture, then rotates either west or east, by 15 or 30 degrees (both options are configurable), twice, and takes 2 other pictures. From these 3 images, it computes 2 vectors that describe the errors in altitude and azimuth. Once these two errors are corrected by adjusting the mount, alignment is completed. This takes only about 5 minutes, and allows an alignment better than 30 arc-seconds. Attention : Ekos simulates E/W button presses until RA has increased/decreased by 15 or 30 degrees. But one feature of TeenAstro is that when the mount points Home (towards the pole), rotating the RA axis does not change the displayed RA value. Therefore Ekos will keep pressing the E or W button forever. Since TeenAstro does not check mount limits in this situation, the telescope will hit the pier sooner or later, and potentially damage camera, filters etc. This means you must be very careful to perform polar alignment from any position near the meridian EXCEPT from Home position Error handling When the telescope is tracking and moves past one of the defined limits, it stops tracking and does not execute any GOTO commands. On the SHC, an icon appears to show the limit. When it is controlled by Ekos, it shows the message in the Main tab of the TeenAstro INDI control panel. In both cases, the procedure to recover is the same: use the arrows (physical buttons on the SHC, or virtual buttons on Ekos) to move the mount back in the safe zone. As soon as the error message disappears, normal operation can resume. Using TeenAstro without the hand controller It is perfectly possible to use this configuration, for example in a fixed pier situation where the mount does not move between uses. The whole functionality is controlled entirely by Ekos on the remote computer. Obviously in this case only a serial connection is possible, since the Wifi module is no longer available. (It is in the SHC).","title":"Ekos"},{"location":"ekos/#teenastro-with-ekos","text":"Ekos is documented here . This gives some detail on its operation with TeenAstro","title":"TeenAstro with Ekos"},{"location":"ekos/#connection-options","text":"KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through Serial / USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). Note: I found that, for visual use, both methods are fine, but for astrophotography the serial port is more reliable than Wifi (especially for guiding). Another choice is which computer runs Ekos, and how it is controlled. To reduce the number of cables, I chose to run it on a Raspberry Pi 4 attached the mount dovetail. I control the Pi 4 remotely via the excellent NoMachine free remote desktop application.","title":"Connection options"},{"location":"ekos/#goto","text":"To control remotely the mount, start Kstars, launch Ekos from the Tool menu. Click on the Mount tab. You get this screen: Click on Mount Control to set the slew speed, select a target, and move in all directions:","title":"Goto"},{"location":"ekos/#guiding","text":"For long exposure astrophotography, the mount must track the stars precisely. To compensate polar alignment errors and refraction effects, we need to guide, by using a guide camera and software (PHD2 or Ekos Guide Module) running on a computer to correct the mount movement. The signals can be either electrical impulsions through an ST4 cable, or software commands from computer to mount (no need for ST4 cable between camera and mount). To select the software mode, enable \"Pulse Guiding\" in the TeenAstro INDI control panel. As noted above, guiding is more reliable with the serial port. For the time being, don't use Wifi for guiding. Other important options in the Guide tab of the control panel are: - Exposure time. I use 1 or 2 seconds. - Guiding rate. I found that 0.5x works best on my setup. - Bin: 2x2 in the Guide Module tab. If you use the Ekos guide module, keep the suggested control parameters (proportional and integral gains). With these settings, in the best case (with excellent seeing) I obtain a guiding error of between 0.5 arc-second and 1 arc-second RMS with my setup (250mm focal length guide scope, ASI120mini camera, AP600 mount)","title":"Guiding"},{"location":"ekos/#phd2-vs-ekos-internal-guiding","text":"Both work. I did not notice significant differences in precision, but I found it easier to use the internal Ekos guiding module (no need to start an external program).","title":"PHD2 vs. Ekos internal guiding"},{"location":"ekos/#meridian-flip","text":"All German Equatorial mounts need to switch from east to west when imaging past the meridian. This is called the Meridian Flip and Ekos provides a way to do this automatically during a session. Here are the steps: - Determine the \"Past Meridian Mount Limit\" of your mount, ie the angle it can continue tracking past the meridian without the telescope hitting the pier. - Program this limit in the mount via the handset or Wifi interface - In the Ekos mount tab, check the box \"Flip if HA>\" and enter the same value minus one degree than the TeenAstro limit. For example, if the TeenAstro limit is 10 degrees, enter 9 degrees in Ekos. Start your photo session. When Ekos detects that the next capture will get close to the limit, it initiates a GOTO to the current target. TeenAstro will perform the flip automatically. In some cases, TeenAstro decides it is not close enough, then Ekos will reschedule it after the next exposure. When the flip is done, Ekos restarts the photo session, after eventually performing an astrometry session to re-center the image (if programmed in the scheduler). Note : The current Ekos official release (January 2022) has a bug that prevents the meridian flip timer from operating. The fix is identified and should be implemented soon.","title":"Meridian Flip"},{"location":"ekos/#polar-alignment","text":"Ekos has a good polar alignment feature, that uses the stellar solver. It works as follows: From a given position, preferably on the meridian (but NOT from the Home position - more on this later), it takes one picture, then rotates either west or east, by 15 or 30 degrees (both options are configurable), twice, and takes 2 other pictures. From these 3 images, it computes 2 vectors that describe the errors in altitude and azimuth. Once these two errors are corrected by adjusting the mount, alignment is completed. This takes only about 5 minutes, and allows an alignment better than 30 arc-seconds. Attention : Ekos simulates E/W button presses until RA has increased/decreased by 15 or 30 degrees. But one feature of TeenAstro is that when the mount points Home (towards the pole), rotating the RA axis does not change the displayed RA value. Therefore Ekos will keep pressing the E or W button forever. Since TeenAstro does not check mount limits in this situation, the telescope will hit the pier sooner or later, and potentially damage camera, filters etc. This means you must be very careful to perform polar alignment from any position near the meridian EXCEPT from Home position","title":"Polar Alignment"},{"location":"ekos/#error-handling","text":"When the telescope is tracking and moves past one of the defined limits, it stops tracking and does not execute any GOTO commands. On the SHC, an icon appears to show the limit. When it is controlled by Ekos, it shows the message in the Main tab of the TeenAstro INDI control panel. In both cases, the procedure to recover is the same: use the arrows (physical buttons on the SHC, or virtual buttons on Ekos) to move the mount back in the safe zone. As soon as the error message disappears, normal operation can resume.","title":"Error handling"},{"location":"ekos/#using-teenastro-without-the-hand-controller","text":"It is perfectly possible to use this configuration, for example in a fixed pier situation where the mount does not move between uses. The whole functionality is controlled entirely by Ekos on the remote computer. Obviously in this case only a serial connection is possible, since the Wifi module is no longer available. (It is in the SHC).","title":"Using TeenAstro without the hand controller"},{"location":"firmware/","text":"TeenAstro Firmware Build The code is maintained on github . It consists of sources in the Arduino framework, used to build the firmware for the 3 processors in the system: - Main Unit (Teensy 3.2 / ARMv7) - Focuser (Teensy 3.2 / ARMv7) - Smart Hand Controller (ESP8266 Wemos / Xtensa lx106) The recommended build environment is now PlatformIO . It is easy to install, takes care of compiler installations, Arduino framework, and works identically on Windows, OSX and Linux. PlatformIO can be used either standalone from the command line, or it can be integrated into an IDE such as VSCode. PlatformIO build For each build, PlatformIO uses a configuration file called platformio.ini , located at the root of the project. This file describes the processor, framework, and directories for sources and libraries. To build from the command line, just type pio run from the project root, and all targets are automatically rebuilt. The executables are located in directory ./pio/target_name For example, the Main Unit executable for board 240, with 5160 stepper driver is at TeenAstro/TeenAstroMainUnit/pio/240_5160 ; PlatformIO Project Configuration File for TeenAstro Main Unit ; ; Defines the different board combinations [platformio] ; Uncomment this line to build just one version, comment it to build all default_envs = 240_5160 lib_dir = ../libraries src_dir = . build_dir = pio [env] platform = teensy framework = arduino extra_scripts = pre:rename_mu.py ; Release version number - used by rename_xx.py for renaming the executable custom_option1 = 122 [env:220] board = teensy31 build_flags = -DVERSION=220 [env:230] board = teensy31 build_flags = -DVERSION=230 [env:240_2130] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=2 [env:240_5160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=3 [env:240_2160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=4 [env:250_5160] board = teensy40 build_flags = -DVERSION=250 -DAxisDriver=3 Uploading the firmware For the main unit, use platformio: type pio run -t upload For the SHC, upload with Wifi interface","title":"Firmware"},{"location":"firmware/#teenastro-firmware-build","text":"The code is maintained on github . It consists of sources in the Arduino framework, used to build the firmware for the 3 processors in the system: - Main Unit (Teensy 3.2 / ARMv7) - Focuser (Teensy 3.2 / ARMv7) - Smart Hand Controller (ESP8266 Wemos / Xtensa lx106) The recommended build environment is now PlatformIO . It is easy to install, takes care of compiler installations, Arduino framework, and works identically on Windows, OSX and Linux. PlatformIO can be used either standalone from the command line, or it can be integrated into an IDE such as VSCode.","title":"TeenAstro Firmware Build"},{"location":"firmware/#platformio-build","text":"For each build, PlatformIO uses a configuration file called platformio.ini , located at the root of the project. This file describes the processor, framework, and directories for sources and libraries. To build from the command line, just type pio run from the project root, and all targets are automatically rebuilt. The executables are located in directory ./pio/target_name For example, the Main Unit executable for board 240, with 5160 stepper driver is at TeenAstro/TeenAstroMainUnit/pio/240_5160 ; PlatformIO Project Configuration File for TeenAstro Main Unit ; ; Defines the different board combinations [platformio] ; Uncomment this line to build just one version, comment it to build all default_envs = 240_5160 lib_dir = ../libraries src_dir = . build_dir = pio [env] platform = teensy framework = arduino extra_scripts = pre:rename_mu.py ; Release version number - used by rename_xx.py for renaming the executable custom_option1 = 122 [env:220] board = teensy31 build_flags = -DVERSION=220 [env:230] board = teensy31 build_flags = -DVERSION=230 [env:240_2130] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=2 [env:240_5160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=3 [env:240_2160] board = teensy31 build_flags = -DVERSION=240 -DAxisDriver=4 [env:250_5160] board = teensy40 build_flags = -DVERSION=250 -DAxisDriver=3","title":"PlatformIO build"},{"location":"firmware/#uploading-the-firmware","text":"For the main unit, use platformio: type pio run -t upload For the SHC, upload with Wifi interface","title":"Uploading the firmware"},{"location":"indi/","text":"Introduction to INDI The INDI Library is a collection of programs designed to control astronomical equipment. Its telescope control platform, called Ekos, controls a TeenAstro mount through an INDI driver. Driver design TeenAstro, like many other mounts, is controlled with a protocol derived from an early Meade telescope, called LX200 . The TeenAstro INDI driver derives directly from the simplest LX200 driver with basic functionality (lx200basic), and adds the TeenAstro specific functions. When available, the existing LX200 functionality is used, if not it is copied from OnStep and other drivers, or implemented from scratch. Repository: https://github.com/indilib/indi Source files : lx200_TeenAstro.cpp, lx200_TeenAstro.h Driver info: indi_lx200_TeenAstro Driver versions Date Version Description Jan 2020 0.8 Basic functionality Apr 2020 1.0 Added error handling for limits, save and restore driver configuration 1 May 2020 1.1 Fixed TCP/IP comms error, set default guide speed to 0.5x 10 May 2020 1.2 Compatibility with Firmware v1.2 (backward compatible with 1.1) Jan 2022 1.2a Fixed slew speed selection Connection options KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above). Mount Type TeenAstro supports German Equatorial, Alt Azimuth, Fork Azimuth and Fork equatorial mounts. However the current driver only supports German Equatorial. Current features GOTO: yes Sync: yes Slew Speeds: Guide, Slow, Medium, Fast, Max. All speeds can be configured through the hand controller. Max speed depends on mount and motors. Track Rates: Sidereal, Solar, Lunar Tracking can be disabled Auto Meridian Flip: no Configurable custom parking positions: yes Pulse-guiding: yes Guide Rates: 0.25x, 0.5x, 1x ST4 Guiding: yes Sync and Alignment (2 or 3-star) is done using the hand controller. The mount needs to be aligned before connecting the driver. Guiding can be done with ST4 or software (pulse-guiding) 4 sites are stored, with their coordinates including altitude (elevation) An optional GPS device can be connected, its functionality is not exposed to the INDI driver. Functionality - standard Meade commands These lists are not complete, but are included here for convenience. Check the source code (Command_xx.ino) for details Function Command Used in INDI driver Get Right Ascension / Declination :GR# :GD# \u2713 Get Azimuth / Altitude :GA# :GZ# Set target RA, Declination :Sr...#, :Sd...# \u2713 Goto target RA/Dec :MS# \u2713 Set target Azimuth / Altitude :Sa...#, :Sz...# Goto target az/alt :MA# Set tracking mode :TQ# :TS# :TL# \u2713 Park / Unpark / Set parking position :HQ# :HR# :HP# \u2713 Sync to current coords/object :CS# :CM# \u2713 pier side / dist to meridian :Gm# Set centering speed (buttons) :R# \u2713 Move N / S / W / E :Mx# \u2713 Display firmware data :GVD# :GVN# etc \u2713 Get current site location, UTC etc :GM# etc. \u2713 Select Site :Wn# \u2713 Send guiding command :Mgn# etc. \u2713 Enable / Disable tracking :Te# :Td# \u2713 Enable / disable refraction correction :Tr# :Tn# Get/Set site altitude :Ge# :Se# \u2713 Functionality - TeenAstro-specific commands All Get commands (:GX..) except :GXI# have a Set (:SX..) counterpart that sets the parameter in TeenAstro Function Command Notes Used in INDI driver Get mount status :GXI# (1) \u2713 Get Acceleration :GXRA# Get Max Rate :GXRX# Get Default Rate :GXRD# Get Custom Rate :GXRn# n is 0 to 3 Get Backlash rate :GXRB# Get Limits :GXLn# n is E/W/U/O/H Get Date/Time :GXTn# n is 0 to 2 Get Backlash values :GXMBn# n is D or R Get Gear :GXMGn# n is D or R Get Steps :GXMSn# n is D or R Get Microsteps :GXMMn# n is D or R Get Direction :GXMRn# n is D or R Get High current :GXMCn# n is D or R Get Low current :GXMcn# n is D or R Get Debug parameters :GXDnn# See Command_G.ino Get Pole Alignment (True / Apparent) :GXApn# See Command_G.ino (1) Status is a 16-character string, coding the status as follows: position char values meaning 0 0, 1, 2 '0' + 2 * movingTo + sideralTracking 1 0, 1 sidereal mode 2 pIPF not [p]arked, parking [I]n-progress, [P]arked, Park [F]ailed 3 space or H at home 4 0 to 3 current slew rate 5 space @ G spiral, guide 6 * + * for guide pulse/ST4, + for guide recenter 7-8 > < b _ see Command_G.ino 9 f fault 10 c corrected tracking 11 0 1 star alignment 12 E K k A U mount type 13 E W pier side 14 0 1 GNSS valid 15 0 to E Last error code - See LX200RETURN in TeenAstroLX200io.h Not implemented Tab Function command Standard Meade In TeenAstro Main control Object info - macro from lx200driver.h :LI# yes no Main control Alignment status :Gw# yes no Main control Elevation limits :Sh# :So# yes yes Motion control Custom track rate (RA / declination) :RA# :RE# yes no Motion control dual axis tracking :T2# no no Motion control Tracking frequency / frequency adjust :T+# :T-# :GT# yes no Align Polar align :MP# no no PEC Periodic Error Correction :QZ# etc. yes no Focuser Focus control :F+ etc. yes yes","title":"INDI driver"},{"location":"indi/#introduction-to-indi","text":"The INDI Library is a collection of programs designed to control astronomical equipment. Its telescope control platform, called Ekos, controls a TeenAstro mount through an INDI driver.","title":"Introduction to INDI"},{"location":"indi/#driver-design","text":"TeenAstro, like many other mounts, is controlled with a protocol derived from an early Meade telescope, called LX200 . The TeenAstro INDI driver derives directly from the simplest LX200 driver with basic functionality (lx200basic), and adds the TeenAstro specific functions. When available, the existing LX200 functionality is used, if not it is copied from OnStep and other drivers, or implemented from scratch. Repository: https://github.com/indilib/indi Source files : lx200_TeenAstro.cpp, lx200_TeenAstro.h Driver info: indi_lx200_TeenAstro","title":"Driver design"},{"location":"indi/#driver-versions","text":"Date Version Description Jan 2020 0.8 Basic functionality Apr 2020 1.0 Added error handling for limits, save and restore driver configuration 1 May 2020 1.1 Fixed TCP/IP comms error, set default guide speed to 0.5x 10 May 2020 1.2 Compatibility with Firmware v1.2 (backward compatible with 1.1) Jan 2022 1.2a Fixed slew speed selection","title":"Driver versions"},{"location":"indi/#connection-options","text":"KStars / Ekos runs either on a PC, Mac or on a Raspberry Pi. The connection between this device and TeenAstro is done either through USB (the Telescope port on the main unit), or through Wifi to the Smart HandController (SHC), port 9999 (IP address depends on the network). When running through Wifi, the SHC requires a firmware version that allows permanent IP connections with the \u201cOne to One\u201d Wifi menu option (SHC version 1.2b or above).","title":"Connection options"},{"location":"indi/#mount-type","text":"TeenAstro supports German Equatorial, Alt Azimuth, Fork Azimuth and Fork equatorial mounts. However the current driver only supports German Equatorial.","title":"Mount Type"},{"location":"indi/#current-features","text":"GOTO: yes Sync: yes Slew Speeds: Guide, Slow, Medium, Fast, Max. All speeds can be configured through the hand controller. Max speed depends on mount and motors. Track Rates: Sidereal, Solar, Lunar Tracking can be disabled Auto Meridian Flip: no Configurable custom parking positions: yes Pulse-guiding: yes Guide Rates: 0.25x, 0.5x, 1x ST4 Guiding: yes Sync and Alignment (2 or 3-star) is done using the hand controller. The mount needs to be aligned before connecting the driver. Guiding can be done with ST4 or software (pulse-guiding) 4 sites are stored, with their coordinates including altitude (elevation) An optional GPS device can be connected, its functionality is not exposed to the INDI driver.","title":"Current features"},{"location":"indi/#functionality-standard-meade-commands","text":"These lists are not complete, but are included here for convenience. Check the source code (Command_xx.ino) for details Function Command Used in INDI driver Get Right Ascension / Declination :GR# :GD# \u2713 Get Azimuth / Altitude :GA# :GZ# Set target RA, Declination :Sr...#, :Sd...# \u2713 Goto target RA/Dec :MS# \u2713 Set target Azimuth / Altitude :Sa...#, :Sz...# Goto target az/alt :MA# Set tracking mode :TQ# :TS# :TL# \u2713 Park / Unpark / Set parking position :HQ# :HR# :HP# \u2713 Sync to current coords/object :CS# :CM# \u2713 pier side / dist to meridian :Gm# Set centering speed (buttons) :R# \u2713 Move N / S / W / E :Mx# \u2713 Display firmware data :GVD# :GVN# etc \u2713 Get current site location, UTC etc :GM# etc. \u2713 Select Site :Wn# \u2713 Send guiding command :Mgn# etc. \u2713 Enable / Disable tracking :Te# :Td# \u2713 Enable / disable refraction correction :Tr# :Tn# Get/Set site altitude :Ge# :Se# \u2713","title":"Functionality - standard Meade commands"},{"location":"indi/#functionality-teenastro-specific-commands","text":"All Get commands (:GX..) except :GXI# have a Set (:SX..) counterpart that sets the parameter in TeenAstro Function Command Notes Used in INDI driver Get mount status :GXI# (1) \u2713 Get Acceleration :GXRA# Get Max Rate :GXRX# Get Default Rate :GXRD# Get Custom Rate :GXRn# n is 0 to 3 Get Backlash rate :GXRB# Get Limits :GXLn# n is E/W/U/O/H Get Date/Time :GXTn# n is 0 to 2 Get Backlash values :GXMBn# n is D or R Get Gear :GXMGn# n is D or R Get Steps :GXMSn# n is D or R Get Microsteps :GXMMn# n is D or R Get Direction :GXMRn# n is D or R Get High current :GXMCn# n is D or R Get Low current :GXMcn# n is D or R Get Debug parameters :GXDnn# See Command_G.ino Get Pole Alignment (True / Apparent) :GXApn# See Command_G.ino (1) Status is a 16-character string, coding the status as follows: position char values meaning 0 0, 1, 2 '0' + 2 * movingTo + sideralTracking 1 0, 1 sidereal mode 2 pIPF not [p]arked, parking [I]n-progress, [P]arked, Park [F]ailed 3 space or H at home 4 0 to 3 current slew rate 5 space @ G spiral, guide 6 * + * for guide pulse/ST4, + for guide recenter 7-8 > < b _ see Command_G.ino 9 f fault 10 c corrected tracking 11 0 1 star alignment 12 E K k A U mount type 13 E W pier side 14 0 1 GNSS valid 15 0 to E Last error code - See LX200RETURN in TeenAstroLX200io.h","title":"Functionality - TeenAstro-specific commands"},{"location":"indi/#not-implemented","text":"Tab Function command Standard Meade In TeenAstro Main control Object info - macro from lx200driver.h :LI# yes no Main control Alignment status :Gw# yes no Main control Elevation limits :Sh# :So# yes yes Motion control Custom track rate (RA / declination) :RA# :RE# yes no Motion control dual axis tracking :T2# no no Motion control Tracking frequency / frequency adjust :T+# :T-# :GT# yes no Align Polar align :MP# no no PEC Periodic Error Correction :QZ# etc. yes no Focuser Focus control :F+ etc. yes yes","title":"Not implemented"},{"location":"mount_sim/","text":"Mount Simulator mountSim is a Python program that connects to a TeenAstro through Wifi and displays a simulated mount. It reads the steps on both axes, and shows the mount's movements, including Meridian Flip (for German Equatorials only) which can help debugging eventual firmware problems. Installation Download the python scripts and STL files from Github. Install Python 3.8 or higher, and the following modules: pip install argparse numpy trimesh glooey pyglet threading serial serial.tools time datetime Launch mountSim from the command line. The single option is the IP address of your TeenAstro. python mountSim.py --ip 192.168.0.21 A graphic window opens, that displays a simplified mount model, selected according to your type of mount: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) You can now move the mount with the hand controller. It is also possible to control TeenAstro remotely, either with the Web interface from the SHC, or through a program running on your PC (Ekos, SkySafari etc.). Note that you can have only one Wifi (IP) port at a time, so the PC program should use USB, not Wifi. You can run mountSim in parallel with your mount, or without. In this case it is possible to speed up the maximum speed up to 2000x or more. (You may need to lower the gear reduction). Use these mouse movements: left-click+drag to change the view orientation, middle-click+drag to pan around. Program Design The program consists of 2 python scripts (mountSim.py and teenastro.py) and STL files that represent the parts of each mount. I used the 3d parametric CAD tool SolveSpace to design the mounts. The display itself is done by the trimesh library and a pyglet viewer. Primer on Mount Design To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal Advantages of each type Equatorial vs Alt-Az Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az. Fork vs. Offset tube Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts. What it means for the mount firmware The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"Mount Simulator"},{"location":"mount_sim/#mount-simulator","text":"mountSim is a Python program that connects to a TeenAstro through Wifi and displays a simulated mount. It reads the steps on both axes, and shows the mount's movements, including Meridian Flip (for German Equatorials only) which can help debugging eventual firmware problems.","title":"Mount Simulator"},{"location":"mount_sim/#installation","text":"Download the python scripts and STL files from Github. Install Python 3.8 or higher, and the following modules: pip install argparse numpy trimesh glooey pyglet threading serial serial.tools time datetime Launch mountSim from the command line. The single option is the IP address of your TeenAstro. python mountSim.py --ip 192.168.0.21 A graphic window opens, that displays a simplified mount model, selected according to your type of mount: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) You can now move the mount with the hand controller. It is also possible to control TeenAstro remotely, either with the Web interface from the SHC, or through a program running on your PC (Ekos, SkySafari etc.). Note that you can have only one Wifi (IP) port at a time, so the PC program should use USB, not Wifi. You can run mountSim in parallel with your mount, or without. In this case it is possible to speed up the maximum speed up to 2000x or more. (You may need to lower the gear reduction). Use these mouse movements: left-click+drag to change the view orientation, middle-click+drag to pan around.","title":"Installation"},{"location":"mount_sim/#program-design","text":"The program consists of 2 python scripts (mountSim.py and teenastro.py) and STL files that represent the parts of each mount. I used the 3d parametric CAD tool SolveSpace to design the mounts. The display itself is done by the trimesh library and a pyglet viewer.","title":"Program Design"},{"location":"mount_sim/#primer-on-mount-design","text":"To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal","title":"Primer on Mount Design"},{"location":"mount_sim/#advantages-of-each-type","text":"","title":"Advantages of each type"},{"location":"mount_sim/#equatorial-vs-alt-az","text":"Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az.","title":"Equatorial vs Alt-Az"},{"location":"mount_sim/#fork-vs-offset-tube","text":"Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts.","title":"Fork vs. Offset tube"},{"location":"mount_sim/#what-it-means-for-the-mount-firmware","text":"The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"What it means for the mount firmware"},{"location":"scopetosky/","text":"Scope to Sky and TeenAstro Mel Bartel\u2019s Scope to Sky calculator , written in Javascript with an HTML user interface, has several functions: - Given sky coordinates (either Right Ascension or Hour Angle, and Declination), compute a telescope\u2019s axis positions. - Given a telescope\u2019s axis positions, compute the corresponding sky coordinates. - For a telescope with encoders, display encoder values for a given telescope position or compute telescope position according to the encoder values. The configuration includes: - Setup site, time and date, time zone - equatorial and altazimuth mounts - Correction for precession, nutation and annual aberration - Correction for refraction - For equatorial mounts, set pier side (mount flip) - Conversion styles (trigonometry or matrix) - Tracking rates algorithms (method for computing the rates) - Encoder gears Notes: - The primary and secondary axes are easy to understand (RA/Dec for eq mounts, Az/Alt for Altaz mounts). The third axis is the rotation of the tube relative to the sky. For equatorial mounts, this is always zero. - The \u201calignment\u201d options include a third option called \u201cstar\u201d. What does this do? - The lower panel, labeled Matrix coordinate conversion, allows setting 2 or 3 alignment positions (each with RA, Dec, Az, Alt and sidereal time) and telescope fabrication errors (misalignments). How does this work? How to use it for testing TeenAstro Firmware We generate a set of test cases (sky positions, site, time etc.), use ScopeToSky to compute axes positions for each, and use them as Goto targets for a TeenAstro. We read the stepper counts for both axes, normalize them back to degrees, and compare with the computed values. Of course this tests only the software part, up to the stepper control signals. Any errors with the motors (stalling etc.) or the mount (backlash, orthogonality etc.) will not be detected. Astro-Physics has an excellent document that explains how to check the mount orthogonality Program design The original ScopeToSky runs from a web page, with a human in front of the screen. For our purpose, it has been ported to run under node.js , from the command line. The functionality is the same, but it is now controlled via a TCP/IP socket. The commands sent by the Python program and the results sent back by ScopeToSky are encoded as a JSON stream (JavaScript Object Notation). The Python program reads configuration from 2 files, a static one (for parameters which do not change between tests) and a dynamic one (for test cases) The static configuration is coded in a YAML file, (which is more readable than JSON, but contains the same data). For the dynamic configuration, we use a CSV file with a list of test cases (one line for each). Each test case contains an arbitrary number of parameters that override the static configuration. For example we can set a different Right Ascension, Declination, pier side, site latitude etc. and get the axis positions for each. The Python program generates the parameters for each test case, sends the GOTO commands to TeenAstro. When the mount stops slewing, it reads the step counts. It then send an equivalent command to ScopeToSky, receives the results, and prints out the results from both, with the differences in arc-seconds. Installing Unzip the archive, install Python 3.7 or above and nodejs v8.10 or above. Install these Python packages: serial , PySerial , ruamel.YAML and telnet , and these nodejs modules: yaml , fs . Running the program 1 - start the ScopeToSky server: change to the scopetosky root directory, run node index.js 2 - run the Python test program: python3 mainUnitTest.py [-c <config_file> -t <testcase_file>] At this time, only computeScope() and computeEquatCoords() are implemented. I don't yet understand the encoders and matrix conversions sections. Sample YAML configuration file In this file, each line corresponds to a control in Mel Bartel\u2019s original web page, arranged in the same sections. The command section describes which command is to be executed, and the fields to display. The output section describes which internal variables we want to display. (see complete list of variables below) config.yaml #command command: computeScope output: RA dec latitude includeRefraction primaryAxis secondaryAxis #coordinates RAHA: '8:00:00' RAorHA: 'RA' dec: '0:00' includeCorrections: false coordinateYear: '2000' # setup currentDateTime: false dateTime: 'Oct 10, 2020 00:00:00' timeZone: '2' latitude: '44.75' longitude: '5.75' # telescope includeRefraction: true alignment: 'equatorial' conversionStyle: 'trig' trackingRatesAlgorithm: 'deltaTime' canFlipMeridian: true flippedState: 'onEastSidePointingWest' flipped: false primaryAxis: '0.0' secondaryAxis: '0.0' Example of test case list In this example, we move to a series of points at declination 50 degrees, and RA from 1 to 14 hr tests.csv RAHA;dec 01:00:00; 50:00:00 00:00:00; 50:00:00 23:00:00; 50:00:00 22:00:00; 50:00:00 21:00:00; 50:00:00 20:00:00; 50:00:00 19:00:00; 50:00:00 18:00:00; 50:00:00 17:00:00; 50:00:00 16:00:00; 50:00:00 15:00:00; 50:00:00 14:00:00; 50:00:00 Results Results are printed in CSV format, easy to load into a worksheet: RA, Dec, computedAxis1, computedAxis2, pierSide, actualAxis1, actualAxis2, delta1, delta2, 01:00:00, 50:00:00, 87.1529, 129.9852, E, 87.1576, 129.9873, 17, 8 00:00:00, 50:00:00, 102.1837, 129.9772, E, 102.1880, 129.9786, 15, 5 23:00:00, 50:00:00, 117.2144, 129.9652, E, 117.2177, 129.9648, 12, -1 22:00:00, 50:00:00, 132.2465, 129.9429, E, 132.2480, 129.9427, 5, -1 21:00:00, 50:00:00, 147.2811, 129.9103, E, 147.2832, 129.9083, 8, -7 20:00:00, 50:00:00, 162.3303, 129.8656, E, 162.3347, 129.8638, 16, -7 19:00:00, 50:00:00, 177.4052, 129.8309, E, 177.4116, 129.8342, 23, 12 18:00:00, 50:00:00, 12.6972, 50.1505, W, 12.7013, 50.1503, 15, -1, -6 17:00:00, 50:00:00, 27.7538, 50.1018, W, 27.7615, 50.1061, 28, 16, -3 16:00:00, 50:00:00, 42.7926, 50.0643, W, 42.8006, 50.0673, 29, 11, 12 15:00:00, 50:00:00, 57.8218, 50.0377, W, 57.8317, 50.0415, 36, 14, -11 14:00:00, 50:00:00, 72.8521, 50.0227, W, 72.8614, 50.0254, 34, 10, -13 13:00:00, 50:00:00, 87.8819, 50.0128, W, 87.8917, 50.0153, 35, 9, 8 These errors can be easily plotted into a chart: Examples of complete test A small Python program (testReport.py) displays the errors in a friendly way. The length of the arrows indicates the differences in arc-seconds between computed and measured coordinates. Note : On a typical screen we have roughly 500 pixels for 100 degrees, or 1 pixel for 12 arc minutes. Therefore the arrows are exaggerated by a factor of 720. TATestReport requires the following Python packages: matplotlib, numpy, pandas. Next steps Right now the test program assumes that the mount is perfectly aligned. The next step will be to display the effect of alignment (2 and 3-star) on the errors. Another possibility is to use the skyfield Python library instead of ScopeToSky. It is modern and very, very precise. List of ScopeToSky variables that can be selected for output This is a subset of the global ScopeToSkyState structure. RAorHA RAHA dec HAOffset JD SidT trackingRates includeCorrections includeRefraction latitude longitude trackingRatesAlgorithm coordinateYear scopeAzimuth scopeAltitude alignment conversionStyle canFlipMeridian flipped primaryAxis secondaryAxis tertiaryAxisa","title":"Testing with ScopeToSky"},{"location":"scopetosky/#scope-to-sky-and-teenastro","text":"Mel Bartel\u2019s Scope to Sky calculator , written in Javascript with an HTML user interface, has several functions: - Given sky coordinates (either Right Ascension or Hour Angle, and Declination), compute a telescope\u2019s axis positions. - Given a telescope\u2019s axis positions, compute the corresponding sky coordinates. - For a telescope with encoders, display encoder values for a given telescope position or compute telescope position according to the encoder values. The configuration includes: - Setup site, time and date, time zone - equatorial and altazimuth mounts - Correction for precession, nutation and annual aberration - Correction for refraction - For equatorial mounts, set pier side (mount flip) - Conversion styles (trigonometry or matrix) - Tracking rates algorithms (method for computing the rates) - Encoder gears Notes: - The primary and secondary axes are easy to understand (RA/Dec for eq mounts, Az/Alt for Altaz mounts). The third axis is the rotation of the tube relative to the sky. For equatorial mounts, this is always zero. - The \u201calignment\u201d options include a third option called \u201cstar\u201d. What does this do? - The lower panel, labeled Matrix coordinate conversion, allows setting 2 or 3 alignment positions (each with RA, Dec, Az, Alt and sidereal time) and telescope fabrication errors (misalignments). How does this work?","title":"Scope to Sky and TeenAstro"},{"location":"scopetosky/#how-to-use-it-for-testing-teenastro-firmware","text":"We generate a set of test cases (sky positions, site, time etc.), use ScopeToSky to compute axes positions for each, and use them as Goto targets for a TeenAstro. We read the stepper counts for both axes, normalize them back to degrees, and compare with the computed values. Of course this tests only the software part, up to the stepper control signals. Any errors with the motors (stalling etc.) or the mount (backlash, orthogonality etc.) will not be detected. Astro-Physics has an excellent document that explains how to check the mount orthogonality","title":"How to use it for testing TeenAstro Firmware"},{"location":"scopetosky/#program-design","text":"The original ScopeToSky runs from a web page, with a human in front of the screen. For our purpose, it has been ported to run under node.js , from the command line. The functionality is the same, but it is now controlled via a TCP/IP socket. The commands sent by the Python program and the results sent back by ScopeToSky are encoded as a JSON stream (JavaScript Object Notation). The Python program reads configuration from 2 files, a static one (for parameters which do not change between tests) and a dynamic one (for test cases) The static configuration is coded in a YAML file, (which is more readable than JSON, but contains the same data). For the dynamic configuration, we use a CSV file with a list of test cases (one line for each). Each test case contains an arbitrary number of parameters that override the static configuration. For example we can set a different Right Ascension, Declination, pier side, site latitude etc. and get the axis positions for each. The Python program generates the parameters for each test case, sends the GOTO commands to TeenAstro. When the mount stops slewing, it reads the step counts. It then send an equivalent command to ScopeToSky, receives the results, and prints out the results from both, with the differences in arc-seconds.","title":"Program design"},{"location":"scopetosky/#installing","text":"Unzip the archive, install Python 3.7 or above and nodejs v8.10 or above. Install these Python packages: serial , PySerial , ruamel.YAML and telnet , and these nodejs modules: yaml , fs .","title":"Installing"},{"location":"scopetosky/#running-the-program","text":"1 - start the ScopeToSky server: change to the scopetosky root directory, run node index.js 2 - run the Python test program: python3 mainUnitTest.py [-c <config_file> -t <testcase_file>] At this time, only computeScope() and computeEquatCoords() are implemented. I don't yet understand the encoders and matrix conversions sections.","title":"Running the program"},{"location":"scopetosky/#sample-yaml-configuration-file","text":"In this file, each line corresponds to a control in Mel Bartel\u2019s original web page, arranged in the same sections. The command section describes which command is to be executed, and the fields to display. The output section describes which internal variables we want to display. (see complete list of variables below) config.yaml #command command: computeScope output: RA dec latitude includeRefraction primaryAxis secondaryAxis #coordinates RAHA: '8:00:00' RAorHA: 'RA' dec: '0:00' includeCorrections: false coordinateYear: '2000' # setup currentDateTime: false dateTime: 'Oct 10, 2020 00:00:00' timeZone: '2' latitude: '44.75' longitude: '5.75' # telescope includeRefraction: true alignment: 'equatorial' conversionStyle: 'trig' trackingRatesAlgorithm: 'deltaTime' canFlipMeridian: true flippedState: 'onEastSidePointingWest' flipped: false primaryAxis: '0.0' secondaryAxis: '0.0'","title":"Sample YAML configuration file"},{"location":"scopetosky/#example-of-test-case-list","text":"In this example, we move to a series of points at declination 50 degrees, and RA from 1 to 14 hr tests.csv RAHA;dec 01:00:00; 50:00:00 00:00:00; 50:00:00 23:00:00; 50:00:00 22:00:00; 50:00:00 21:00:00; 50:00:00 20:00:00; 50:00:00 19:00:00; 50:00:00 18:00:00; 50:00:00 17:00:00; 50:00:00 16:00:00; 50:00:00 15:00:00; 50:00:00 14:00:00; 50:00:00","title":"Example of test case list"},{"location":"scopetosky/#results","text":"Results are printed in CSV format, easy to load into a worksheet: RA, Dec, computedAxis1, computedAxis2, pierSide, actualAxis1, actualAxis2, delta1, delta2, 01:00:00, 50:00:00, 87.1529, 129.9852, E, 87.1576, 129.9873, 17, 8 00:00:00, 50:00:00, 102.1837, 129.9772, E, 102.1880, 129.9786, 15, 5 23:00:00, 50:00:00, 117.2144, 129.9652, E, 117.2177, 129.9648, 12, -1 22:00:00, 50:00:00, 132.2465, 129.9429, E, 132.2480, 129.9427, 5, -1 21:00:00, 50:00:00, 147.2811, 129.9103, E, 147.2832, 129.9083, 8, -7 20:00:00, 50:00:00, 162.3303, 129.8656, E, 162.3347, 129.8638, 16, -7 19:00:00, 50:00:00, 177.4052, 129.8309, E, 177.4116, 129.8342, 23, 12 18:00:00, 50:00:00, 12.6972, 50.1505, W, 12.7013, 50.1503, 15, -1, -6 17:00:00, 50:00:00, 27.7538, 50.1018, W, 27.7615, 50.1061, 28, 16, -3 16:00:00, 50:00:00, 42.7926, 50.0643, W, 42.8006, 50.0673, 29, 11, 12 15:00:00, 50:00:00, 57.8218, 50.0377, W, 57.8317, 50.0415, 36, 14, -11 14:00:00, 50:00:00, 72.8521, 50.0227, W, 72.8614, 50.0254, 34, 10, -13 13:00:00, 50:00:00, 87.8819, 50.0128, W, 87.8917, 50.0153, 35, 9, 8 These errors can be easily plotted into a chart:","title":"Results"},{"location":"scopetosky/#examples-of-complete-test","text":"A small Python program (testReport.py) displays the errors in a friendly way. The length of the arrows indicates the differences in arc-seconds between computed and measured coordinates. Note : On a typical screen we have roughly 500 pixels for 100 degrees, or 1 pixel for 12 arc minutes. Therefore the arrows are exaggerated by a factor of 720. TATestReport requires the following Python packages: matplotlib, numpy, pandas.","title":"Examples of complete test"},{"location":"scopetosky/#next-steps","text":"Right now the test program assumes that the mount is perfectly aligned. The next step will be to display the effect of alignment (2 and 3-star) on the errors. Another possibility is to use the skyfield Python library instead of ScopeToSky. It is modern and very, very precise.","title":"Next steps"},{"location":"scopetosky/#list-of-scopetosky-variables-that-can-be-selected-for-output","text":"This is a subset of the global ScopeToSkyState structure. RAorHA RAHA dec HAOffset JD SidT trackingRates includeCorrections includeRefraction latitude longitude trackingRatesAlgorithm coordinateYear scopeAzimuth scopeAltitude alignment conversionStyle canFlipMeridian flipped primaryAxis secondaryAxis tertiaryAxisa","title":"List of ScopeToSky variables that can be selected for output"},{"location":"troubleshooting/","text":"Troubleshooting This section describes common problems and how to fix them. Mount goes in the wrong direction Check that RA and DEC cables are connected correctly, change the direction of either axis in the SHC \"Mount\" menu. In general, set the mount to its Home position (using the clutches) before switching it on. Make sure the pier side reported by TeenAstro corresponds to the actual mount position. If not, it can be changed through the SHC menu, and synchronize to an object afterwards. High-pitched noise from motors Either the mount movement is blocked, or your slewing speed is too high for the motor / voltage combination Mount goes into altitude error when it should not Check your site latitude and longitude. Mount stops tracking Check altitude / meridian limits (icons on SHC) Connecting to the Main Unit through telnet or serial port To diagnose communication problems, especially with astronomy software running on a PC, it is convenient to connect to the main unit via telnet: telnet <IP address> 9999 or via the serial port / USB: cu -p /dev/ttyACM0 You can retrieve the IP address of TeenAstro on the SHC menu. Once connected, you can issue any LX200 command and view the result. For example, the standard command :GR# returns the current Right Ascension. telnet 192.168.0.12 9999 Trying 192.168.0.12... Connected to 192.168.0.12. Escape character is '^]'. :GR# 16:14:05# When connecting via telnet, the Wifi connection mode must be set to \"One to One\" (SHC Wifi menu). Check the list of commands supported by TeenAstro at this address","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"This section describes common problems and how to fix them.","title":"Troubleshooting"},{"location":"troubleshooting/#mount-goes-in-the-wrong-direction","text":"Check that RA and DEC cables are connected correctly, change the direction of either axis in the SHC \"Mount\" menu. In general, set the mount to its Home position (using the clutches) before switching it on. Make sure the pier side reported by TeenAstro corresponds to the actual mount position. If not, it can be changed through the SHC menu, and synchronize to an object afterwards.","title":"Mount goes in the wrong direction"},{"location":"troubleshooting/#high-pitched-noise-from-motors","text":"Either the mount movement is blocked, or your slewing speed is too high for the motor / voltage combination","title":"High-pitched noise from motors"},{"location":"troubleshooting/#mount-goes-into-altitude-error-when-it-should-not","text":"Check your site latitude and longitude.","title":"Mount goes into altitude error when it should not"},{"location":"troubleshooting/#mount-stops-tracking","text":"Check altitude / meridian limits (icons on SHC)","title":"Mount stops tracking"},{"location":"troubleshooting/#connecting-to-the-main-unit-through-telnet-or-serial-port","text":"To diagnose communication problems, especially with astronomy software running on a PC, it is convenient to connect to the main unit via telnet: telnet <IP address> 9999 or via the serial port / USB: cu -p /dev/ttyACM0 You can retrieve the IP address of TeenAstro on the SHC menu. Once connected, you can issue any LX200 command and view the result. For example, the standard command :GR# returns the current Right Ascension. telnet 192.168.0.12 9999 Trying 192.168.0.12... Connected to 192.168.0.12. Escape character is '^]'. :GR# 16:14:05# When connecting via telnet, the Wifi connection mode must be set to \"One to One\" (SHC Wifi menu). Check the list of commands supported by TeenAstro at this address","title":"Connecting to the Main Unit through telnet or serial port"}]}
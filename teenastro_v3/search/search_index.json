{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TeenAstro Software Design TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe the current version as of December 2022 (2.x), its shortcomings, and the proposal for a version 3.","title":"Home"},{"location":"#teenastro-software-design","text":"TeenAstro is an open source telescope mount controller derived from OnStep , with a user interface based on the FS2 system by Astro Electronic (Michael Koch). It is fully documented at https://groups.io/g/TeenAstro/wiki/home The software consists of: Firmware for the Main Unit and for the Smart Hand Controller, drivers for interfacing with a computer ( ASCOM and INDI ), and utilities for flashing (programming) and configuring the boards. The documents on this site describe the current version as of December 2022 (2.x), its shortcomings, and the proposal for a version 3.","title":"TeenAstro Software Design"},{"location":"teenastro_debug/","text":"Introduction This describes the platforms and tools for debugging the TeenAstro Main Unit software. Debugging platforms The simplest debug platform is a stand-alone processor like this Teensy4.1. I added a LED to display the error status, useful for testing limits. Obviously this is limited to simulation with Step/Dir drivers, since the SPI mode needs functioning TMC5160 hardware to read the motor positions. An ESP32 with a breadboard adds JTAG (see below) and the capability of driving motors through 5160 BOB. An SHC can be connected to the serial port. Debug tools The ESP32 has JTAG support, which, together with a J-Link probe, allows the use of a full-featured debugger like VSCode. I can set breakpoints, watch variables and memory. For tracing communications on serial ports between components (main unit, SHC, focuser etc.), a small logic analyzer like a Saleae (or clone) is very useful. Finally, an oscilloscope can be used for tracing low-level issues. Software simulation mountSim and autoTest are Python programs that interfaces to the Main Unit through a serial port. MountSim displays a mount moving in real-time. autoTest can execute commands or run sequences of movements.","title":"TeenAstro debug"},{"location":"teenastro_debug/#introduction","text":"This describes the platforms and tools for debugging the TeenAstro Main Unit software.","title":"Introduction"},{"location":"teenastro_debug/#debugging-platforms","text":"The simplest debug platform is a stand-alone processor like this Teensy4.1. I added a LED to display the error status, useful for testing limits. Obviously this is limited to simulation with Step/Dir drivers, since the SPI mode needs functioning TMC5160 hardware to read the motor positions. An ESP32 with a breadboard adds JTAG (see below) and the capability of driving motors through 5160 BOB. An SHC can be connected to the serial port.","title":"Debugging platforms"},{"location":"teenastro_debug/#debug-tools","text":"The ESP32 has JTAG support, which, together with a J-Link probe, allows the use of a full-featured debugger like VSCode. I can set breakpoints, watch variables and memory. For tracing communications on serial ports between components (main unit, SHC, focuser etc.), a small logic analyzer like a Saleae (or clone) is very useful. Finally, an oscilloscope can be used for tracing low-level issues.","title":"Debug tools"},{"location":"teenastro_debug/#software-simulation","text":"mountSim and autoTest are Python programs that interfaces to the Main Unit through a serial port. MountSim displays a mount moving in real-time. autoTest can execute commands or run sequences of movements.","title":"Software simulation"},{"location":"teenastro_v2/","text":"Introduction This is a description of the TeenAstro software. It consists of 2 main parts, the Main Unit and the SHC (Smart Hand Controller). Main Unit The current design (2022) Main Unit runs on a Teensy 3.2 board. This is based on an ARM Cortex M4 processor, with peripherals (UART, timer, SPI, etc.). The stepper controllers are TMC2130 or TMC2160 from Trinamic in STEP/DIR mode. The software is built with the Arduino framework (setup / loop) and consists of 3 main parts: the Main Loop, the Timer Loop and the Motor Interrupts. Without an operating system, it relies on global variables. To prevent concurrent variable accesses between the 3 contexts, it disables interrupts (cli / sei). Main Loop The Main loop runs every 10mS (sidereal). It polls for commands from both UARTs (SHC and USB), which handle identical commands based on the LX200 standard (Goto, track, guide etc) with proprietary extensions. It computes the positions and speeds of both axes, then checks for safety limits. Positioning Mode (Goto) Much of the code is common between Eq and Altaz mounts. The simplified call sequence for a Goto RA/Dec command is as follows: GotoEqu(HA, Dec) // LX200 command EquToHor(HA, Dec) // computes target Az/Alt goToHor(Az, Alt) // can also be called directly by LX200 command toInstrumentalDeg(Az, Alt) // matrix operation that computes axes positions as floating-point degrees predictTarget() // converts degrees to steps (long integers), taking into account the gear ratio Angle2InsrtAngle // corrects positions according to pier side if needed Goto(Axis1, Axis2) // check for errors, then sets targets for both axes For retrieving current RA/Dec: getEqu() // LX200 command :GR#, :GD# getHorApp() // retrieves axis positions in steps and converts to degrees toReferenceDeg() // matrix operation - converts axis degrees to sky Az/Alt HorTopoToEqu() // converts Az/Alt to HA/Dec Mapping sky coordinates to axis angles The difference between Eq and AltAz mounts is handled inside the alignment matrix operations (toInstrumentalDeg / toReferenceDeg) based on Toshimi Taki's 2004 paper . At initialization, the alignment matrix is initialized as follows: - for AltAz mounts, Axis1 is Azimuth reversed by 180\u00ba, Axis2 is Altitude, so that in the Home position the optical tube is horizontal, pointing South. - for Eq mounts, it converts Axis1/Axis2 to Altitude and Azimuth, so that in the Home position the optical tube points to the celestial pole. The idea is to perform all Goto with the same (AltAz) code. This simplifies somewhat the design, but has several disadvantages: - It causes problems near the poles, especially for polar alignment software: If we rotate the RA axis when pointing at the pole, the new AltAz position will be identical, since the tube still points at the pole, therefore the reported RA does not change, even though the RA axis has rotated. - It hides the amount of conversions going on behind the scenes (see tracking section below) Mapping axis angles to steps This mapping is not one-to-one: The same position (in steps) may represent 2 different axis angles, according to the hemisphere. This also applies to the direction of tracking. The motor reverse bit is handled at the very lowest level so that the whole software uses the same coordinates for direct and reverse directions. Slewing Mode Slewing or centering is triggered by pressing direction keys. It moves the mount at predefined speeds in any direction, without a target. This is the call sequence: MoveAxis1/2 // LX200 command MoveAxis1/2atRate (rate) // directy sets the motor timers Tracking Tracking does not use a fixed velocity for the RA axis, but repeated positioning mode on a moving pseudo-target. For an Eq mount, it goes like this: computeTrackingRate // :Te# LX200 command. This enters the tracking mode called by the main loop: do_compensation_calc() // Computes positions behind and ahead of the current position: for each position getEqu() getHorApp() // retrieves RA/Dec axis positions in steps and converts to degrees toReferenceDeg() // converts axis degrees to sky Az/Alt - matrix operation horAppToEqu() // convert Az/Alt to RA/Dec - trig operation equToHor() // convert RA/Dec to Az/Alt - trig operation toInstrumentalDeg() // convert Az/Alt to RA/Dec axis degrees - matrix operation instrtoStep() // axis degrees to steps compute difference between the 2 axis positions, derive a speed then set the motor timers Guiding Guiding for astrophoto is performed either by signals on the ST4 connector emulating button presses, or by software commands. It increases or decreases the tracking speed on both axes. The code is somewhat confusing because the term is used both for centering (SHC button presses) and for automatic guiding via software (PHD2 etc.) enableST4GuideRate() // :Mgdnnnn# Pulse guide command PerformPulseGuiding() apply_GuidingA1() // modify the tracking pseudo-target Timer Loop The timer loop is triggered by a hardware timer that runs every 10mS (sidereal). From the current mode (Goto, track, guide etc.) it computes and programs the periods (rates) for both motor interrupts. Motor Interrupts There is one motor interrupt handler for each axis motor. Each one runs at a period determined by the axis speed and controls the STEP and DIR inputs of the TMC motor controller. Smart Hand Controller The SHC handles all user interface, as well as the databases for deep-sky objects, and the solar system computations. It is currently implemented on a Wemos processor that includes a Wifi interface. The peripherals are 7 buttons, a screen controlled by I2C, and a UART connected to the Main Unit. All commands and response follow the LX200 standard, with proprietary additions. Primer on Mount Design To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal Advantages of each type Equatorial vs Alt-Az Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az. Fork vs. Offset tube Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts. What it means for the mount firmware The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"TeenAstro V2"},{"location":"teenastro_v2/#introduction","text":"This is a description of the TeenAstro software. It consists of 2 main parts, the Main Unit and the SHC (Smart Hand Controller).","title":"Introduction"},{"location":"teenastro_v2/#main-unit","text":"The current design (2022) Main Unit runs on a Teensy 3.2 board. This is based on an ARM Cortex M4 processor, with peripherals (UART, timer, SPI, etc.). The stepper controllers are TMC2130 or TMC2160 from Trinamic in STEP/DIR mode. The software is built with the Arduino framework (setup / loop) and consists of 3 main parts: the Main Loop, the Timer Loop and the Motor Interrupts. Without an operating system, it relies on global variables. To prevent concurrent variable accesses between the 3 contexts, it disables interrupts (cli / sei).","title":"Main Unit"},{"location":"teenastro_v2/#main-loop","text":"The Main loop runs every 10mS (sidereal). It polls for commands from both UARTs (SHC and USB), which handle identical commands based on the LX200 standard (Goto, track, guide etc) with proprietary extensions. It computes the positions and speeds of both axes, then checks for safety limits.","title":"Main Loop"},{"location":"teenastro_v2/#positioning-mode-goto","text":"Much of the code is common between Eq and Altaz mounts. The simplified call sequence for a Goto RA/Dec command is as follows: GotoEqu(HA, Dec) // LX200 command EquToHor(HA, Dec) // computes target Az/Alt goToHor(Az, Alt) // can also be called directly by LX200 command toInstrumentalDeg(Az, Alt) // matrix operation that computes axes positions as floating-point degrees predictTarget() // converts degrees to steps (long integers), taking into account the gear ratio Angle2InsrtAngle // corrects positions according to pier side if needed Goto(Axis1, Axis2) // check for errors, then sets targets for both axes For retrieving current RA/Dec: getEqu() // LX200 command :GR#, :GD# getHorApp() // retrieves axis positions in steps and converts to degrees toReferenceDeg() // matrix operation - converts axis degrees to sky Az/Alt HorTopoToEqu() // converts Az/Alt to HA/Dec","title":"Positioning Mode (Goto)"},{"location":"teenastro_v2/#mapping-sky-coordinates-to-axis-angles","text":"The difference between Eq and AltAz mounts is handled inside the alignment matrix operations (toInstrumentalDeg / toReferenceDeg) based on Toshimi Taki's 2004 paper . At initialization, the alignment matrix is initialized as follows: - for AltAz mounts, Axis1 is Azimuth reversed by 180\u00ba, Axis2 is Altitude, so that in the Home position the optical tube is horizontal, pointing South. - for Eq mounts, it converts Axis1/Axis2 to Altitude and Azimuth, so that in the Home position the optical tube points to the celestial pole. The idea is to perform all Goto with the same (AltAz) code. This simplifies somewhat the design, but has several disadvantages: - It causes problems near the poles, especially for polar alignment software: If we rotate the RA axis when pointing at the pole, the new AltAz position will be identical, since the tube still points at the pole, therefore the reported RA does not change, even though the RA axis has rotated. - It hides the amount of conversions going on behind the scenes (see tracking section below)","title":"Mapping sky coordinates to axis angles"},{"location":"teenastro_v2/#mapping-axis-angles-to-steps","text":"This mapping is not one-to-one: The same position (in steps) may represent 2 different axis angles, according to the hemisphere. This also applies to the direction of tracking. The motor reverse bit is handled at the very lowest level so that the whole software uses the same coordinates for direct and reverse directions.","title":"Mapping axis angles to steps"},{"location":"teenastro_v2/#slewing-mode","text":"Slewing or centering is triggered by pressing direction keys. It moves the mount at predefined speeds in any direction, without a target. This is the call sequence: MoveAxis1/2 // LX200 command MoveAxis1/2atRate (rate) // directy sets the motor timers","title":"Slewing Mode"},{"location":"teenastro_v2/#tracking","text":"Tracking does not use a fixed velocity for the RA axis, but repeated positioning mode on a moving pseudo-target. For an Eq mount, it goes like this: computeTrackingRate // :Te# LX200 command. This enters the tracking mode called by the main loop: do_compensation_calc() // Computes positions behind and ahead of the current position: for each position getEqu() getHorApp() // retrieves RA/Dec axis positions in steps and converts to degrees toReferenceDeg() // converts axis degrees to sky Az/Alt - matrix operation horAppToEqu() // convert Az/Alt to RA/Dec - trig operation equToHor() // convert RA/Dec to Az/Alt - trig operation toInstrumentalDeg() // convert Az/Alt to RA/Dec axis degrees - matrix operation instrtoStep() // axis degrees to steps compute difference between the 2 axis positions, derive a speed then set the motor timers","title":"Tracking"},{"location":"teenastro_v2/#guiding","text":"Guiding for astrophoto is performed either by signals on the ST4 connector emulating button presses, or by software commands. It increases or decreases the tracking speed on both axes. The code is somewhat confusing because the term is used both for centering (SHC button presses) and for automatic guiding via software (PHD2 etc.) enableST4GuideRate() // :Mgdnnnn# Pulse guide command PerformPulseGuiding() apply_GuidingA1() // modify the tracking pseudo-target","title":"Guiding"},{"location":"teenastro_v2/#timer-loop","text":"The timer loop is triggered by a hardware timer that runs every 10mS (sidereal). From the current mode (Goto, track, guide etc.) it computes and programs the periods (rates) for both motor interrupts.","title":"Timer Loop"},{"location":"teenastro_v2/#motor-interrupts","text":"There is one motor interrupt handler for each axis motor. Each one runs at a period determined by the axis speed and controls the STEP and DIR inputs of the TMC motor controller.","title":"Motor Interrupts"},{"location":"teenastro_v2/#smart-hand-controller","text":"The SHC handles all user interface, as well as the databases for deep-sky objects, and the solar system computations. It is currently implemented on a Wemos processor that includes a Wifi interface. The peripherals are 7 buttons, a screen controlled by I2C, and a UART connected to the Main Unit. All commands and response follow the LX200 standard, with proprietary additions.","title":"Smart Hand Controller"},{"location":"teenastro_v2/#primer-on-mount-design","text":"To point any direction in the sky, a telescope mount requires (at least) 2 orthogonal axes. In practice these two types exist: Alt-Az: Primary axis is vertical, secondary axis is horizontal. Equatorial: Primary axis points to celestial pole, secondary axis sweeps along a meridian. Within these two main types, there are several design options: - Fork: Optical tube is in the same plane as the primary axis. - Offset: Optical tube is offset to the side of the primary axis. Usually requires a counterweight. Therefore TeenAstro can be configured for any of these 4 types of mounts: Fork Offset Alt-Az Alt-Az Fork Alt-Az T-Mount Equatorial Equatorial Fork German Equatorial (GEM) Note that some systems do not fit in any of these categories. For example a Dobson telescope on an equatorial table actually has 3 axes: The primary is a kind of horseshoe (equatorial fork), on which an Alt-Az fork is sitting, but not horizontal. But it works! Also note these interesting cases: - at the North or South pole, an Alt-Az mount is also an equatorial - at the equator, the primary axis of an equatorial mount is horizontal","title":"Primer on Mount Design"},{"location":"teenastro_v2/#advantages-of-each-type","text":"","title":"Advantages of each type"},{"location":"teenastro_v2/#equatorial-vs-alt-az","text":"Equatorial mounts follow the sky with only one motor on the right ascension (hour) primary axis. The object always stays in the same orientation, there is no field rotation. In contrast, Alt-Az mounts need two motors to track, and the field rotates during tracking, requiring a derotator to make images. Alt-Az mounts are mechanically simpler and lighter. The last large equatorial mount was the 200-inch (5.1m) Hale at Mount Palomar (1949). Modern large telescopes are all Alt-Az.","title":"Equatorial vs Alt-Az"},{"location":"teenastro_v2/#fork-vs-offset-tube","text":"Equatorial forks are generally bulky and reserved for large instruments. Alt-Az forks are common for amateur telescopes (especially for Schmidt-Cassegrain with short fat tubes). Most amateur telescopes intended for astrophoto are GEM mounts.","title":"Fork vs. Offset tube"},{"location":"teenastro_v2/#what-it-means-for-the-mount-firmware","text":"The main task of a modern GOTO mount firmware is the computation of axis positions from the object's sky coordinates . For Alt-Az, the axis positions are the required altitude and azimuth. For Equatorial, the axis positions are the Hour Angle (Local sidereal time - Right Ascension of object) and the object's declination (with a positive or negative sign, depending on the RA axis position) In both cases the computation is the same for fork or offset mounts, but the limits are different. For example, a GEM (German Equatorial) cannot track continuously across the southern sky. It needs to perform a meridian flip . Equatorial Fork mounts usually cannot track below the pole.","title":"What it means for the mount firmware"},{"location":"teenastro_v3/","text":"TeenAstroV3 Introduction Here are some of the design requirements for a new design of the TeenAstro Main Unit. Modular, easier to read and to maintain than v2 Support for multiple processors Support Step/Dir steppers, MotionControl (SPI-only) steppers, DC servo motors Encoders: on axis (absolute), on axis (relative), on worm (relative), on motor (relative) The original TeenAstro used a Teensy 3.2 processor. Since this is now Unobtainium, it is necessary to plan for upgrades to other processors. A logical alternative is Teensy 4.x, but also the ESP32 family. These newer processors already have ports of FreeRTOS. Operating system A real-time OS has many advantages compared to the Arduino setup/loop model, in terms of software portability and readability. FreeRTOS is the de-facto standard for this class of projects, and it is available for both ESP32 and Teensy 4. I have started this porting project on an ESP32, because it has excellent JTAG debug capability, which Teensy 4.x does not have. However it is simple to rebuild the code for both platforms with simple #ifdef statements and to test it in parallel. Software Design File Formats I have removed the funky Arduino .INO format and used standard .h headers and .cpp sources. Much of the code is unchanged, in particular the math calculations. However all low-level code that handles timers and interrupts is new. Program Structure There are now 3 main tasks (Command, Control, Monitor) plus one task for each motor driver (in Step/Drive mode) The Command task handles communication with the 2 serial ports, and does the high-level computation of positions and speeds The Control task contains the logic for the main states of operation (Tracking, Goto) The Monitor task controls the limits and does general housekeeping The Motor tasks control the motors with either Step/Dir or Motion Controller (or servos etc.) The upper-level tasks do all their computations in angles (double floating point), axis positions (32-bit int) and speeds, either in multiples of sidereal speed, or in steps per second (both double floating point). All the computation of periods for programming the timers is done in the Motor tasks. Alignment, Equatorial vs AltAz mounts TeenAstro v2 uses alignment matrices for 2 purposes: for the sky model (mapping sky coordinates to instrument coordinates) to handle the differences between the two kinds of mounts, by considering that an Eq mount is simply an AltAz mount oriented towards the pole. As noted in the v2 document, this has several disadvantages. For v3, the alignment matrix only maps the sky coordinates to instrument coordinates, and all mount-dependent code is isolated in 2 different classes , one for each type of mount. Each class has its own goto, tracking etc. routines. This way we only test the mount type once at startup, and in most cases we no longer need to call isAltAz() or similar functions at run-time. Mapping sky coordinates to axis angles Equatorial Mounts Mapping axis positions to sky coordinates seems simple, but requires careful definitions. For an equatorial mount, Axis1 is the Hour Angle and Axis2 is the Declination. A GEM mount in the Home Position points to the pole, with its DEC axis vertical. From this position, the DEC axis can move either clockwise (as seen from the top), in which case it points towards the geographic east, or counterclockwise, to point to geographic west. Following Mel Bartels, the grand-daddy of telescope mount controllers , we define the home position as Axis2 = zero, the counterclockwise orientation as \"direct\" (Axis2 > 0, Pier Side=East) and the clockwise orientation as \"flipped\" (Axis2 < 0, Pier Side=West). We can now plot the following relations between axes and coordinates, for a GEM mount in the northern hemisphere. For the southern hemisphere, both plots are reversed. Note that equatorial forks are different (to be done). ha_direct = axis1+90, ha_flipped=axis1-90 dec = 90+axis2[-90..0], dec=90-axis2[0..90] AltAz Mounts For AltAz mounts, Axis1 is the azimuth and Axis2 is the altitude. Home position is defined as Alt=0, pointing away from the pole (in the Northern hemisphere: az=180\u00ba, alt=0\u00ba, in the Southern Hemisphere, az=0\u00ba, alt=0\u00ba). We define the Axis1 direction as positive for Clockwise, like the azimuth. Azimuth = Axis1 mod 360 Altitude = Axis2 Implementation Details Hardware Abstraction Layer (HAL) The Arduino framework and libraries already provide most of the abstraction layer (UART, SPI etc.), but some functionality still requires #ifdef in the code. This includes: Chip-specific code chip reset programming hardware timers installing and running interrupt service routines (ISR) non-volatile memory Board-specific code Pin definitions and multiplexing other peripherals on the PCB (real-time clock) Until now, we have been inserting #ifdef statements throughout the code, which is not very readable or portable. A better solution would be an abstraction layer that encapsulates all chip and board-specific code like this: HAL.h #ifdef BOARD_240 // the current TeenAstro board #include teensy_3_2.h #include board_240.h #endif #ifdef BOARD_250 // TiNico's Teensy 4 board #include teensy_4_0.h #include board_250.h #endif #ifdef BOARD_ESP32 // John's ESP32 board #include esp32_s3.h #include board_esp32.h #endif teensy_3_2.h #define ISR(f) void f(void) void beginTimers(void) { ... } esp32_s3.h #define ISR(f) void IRAM_ATTR f(void) hw_timer_t *timerP = NULL; void beginTimers(void) { ... } Timers The ISR running off the sidereal timer has only one purpose, which is to update the sidereal time. All other tasks run at multiples of the operating system's tick, normally one millisecond. Non-Volatile Memory On ESP32 there is no EEPROM, but a section of RAM that emulates EEPROM, and gets written into the Flash with the EEPROM.commit() function. To keep the code compatible, the Monitor task performs a hash of the RAM (every 10 seconds or so) and commits it to Flash when a change is detected. Motion Control (SPI-only) mode of the 5160 stepper controller The TeenAstrov2 code base uses the STEP/DIR mode for controlling the stepper motor driver (TMC2130 or TMC5160). This requires the microcontroller to toggle the STEP input of the driver for each step. Since we use microstepping to get a smooth motion, we program one interrupt for each microstep. The interrupt period is t = 24 * 3600 / (gear reduction * steps/rot * microsteps) For example, for a gear reduction of 1000 (ratio of motor axis to mount axis rotations), typical motors with 200 steps/rotation, 32 microsteps, and sidereal rate (one mount axis rotation for 24 hours), our interrupt period is: t = 24 * 3600 / (1000 * 200 * 32) = 13.5mS. At higher slew speeds, the interrupt period is reduced proportionally: at a slew speed of 100x, the period is 13.5mS / 100 = 135\u00b5S. In turn, the minimum interrupt period of the microcontroller limits the maximum slew speed. (to 675x in our example for the Teensy 3.2). The corresponding step size for the motor axis is 360\u00ba / (gear reduction * steps/rot * microsteps). In our example, the step size is 360 / (1000 * 200 * 32) = 0.000056\u00ba = 0.2\" (arc-seconds). This step size should be kept as low as possible to ensure smooth tracking and guiding. The Trinamic 5160 can run without STEP/DIR interrupts and can control the motor directly through the SPI without requiring a microcontroller interrupt at each step. Therefore we can use the highest possible microstep value (128) and the highest slew rate that the motors can handle. (We are only limited by the maximum torque). Motor API All the motor functionality is accessed through this API. The device driver for each type of motor (Step/Dir, MotionControl, Servo) implements these functions. class MotionControl { public: virtual void init(void); virtual void setCurrentPos(long); virtual void setTargetPos(long); virtual void setVmax(double); virtual void setAmax(long); virtual long getCurrentPos(void); virtual long getTargetPos(void); virtual double getSpeed(void); virtual bool positionReached(void); virtual bool isSlewing(void); virtual void adjustSpeed(double); }; Hardware For the SPI-only mode, we need the 5160 BOB (Breakout Board), not the 5160 SilentStepStick, for 2 reasons: set SD_MODE to GND to use the internal step generator connect an external clock to the CLK input. Without this external clock, the precision is +-4%, obviously unusable in our case","title":"TeenAstro V3"},{"location":"teenastro_v3/#teenastrov3","text":"","title":"TeenAstroV3"},{"location":"teenastro_v3/#introduction","text":"Here are some of the design requirements for a new design of the TeenAstro Main Unit. Modular, easier to read and to maintain than v2 Support for multiple processors Support Step/Dir steppers, MotionControl (SPI-only) steppers, DC servo motors Encoders: on axis (absolute), on axis (relative), on worm (relative), on motor (relative) The original TeenAstro used a Teensy 3.2 processor. Since this is now Unobtainium, it is necessary to plan for upgrades to other processors. A logical alternative is Teensy 4.x, but also the ESP32 family. These newer processors already have ports of FreeRTOS.","title":"Introduction"},{"location":"teenastro_v3/#operating-system","text":"A real-time OS has many advantages compared to the Arduino setup/loop model, in terms of software portability and readability. FreeRTOS is the de-facto standard for this class of projects, and it is available for both ESP32 and Teensy 4. I have started this porting project on an ESP32, because it has excellent JTAG debug capability, which Teensy 4.x does not have. However it is simple to rebuild the code for both platforms with simple #ifdef statements and to test it in parallel.","title":"Operating system"},{"location":"teenastro_v3/#software-design","text":"","title":"Software Design"},{"location":"teenastro_v3/#file-formats","text":"I have removed the funky Arduino .INO format and used standard .h headers and .cpp sources. Much of the code is unchanged, in particular the math calculations. However all low-level code that handles timers and interrupts is new.","title":"File Formats"},{"location":"teenastro_v3/#program-structure","text":"There are now 3 main tasks (Command, Control, Monitor) plus one task for each motor driver (in Step/Drive mode) The Command task handles communication with the 2 serial ports, and does the high-level computation of positions and speeds The Control task contains the logic for the main states of operation (Tracking, Goto) The Monitor task controls the limits and does general housekeeping The Motor tasks control the motors with either Step/Dir or Motion Controller (or servos etc.) The upper-level tasks do all their computations in angles (double floating point), axis positions (32-bit int) and speeds, either in multiples of sidereal speed, or in steps per second (both double floating point). All the computation of periods for programming the timers is done in the Motor tasks.","title":"Program Structure"},{"location":"teenastro_v3/#alignment-equatorial-vs-altaz-mounts","text":"TeenAstro v2 uses alignment matrices for 2 purposes: for the sky model (mapping sky coordinates to instrument coordinates) to handle the differences between the two kinds of mounts, by considering that an Eq mount is simply an AltAz mount oriented towards the pole. As noted in the v2 document, this has several disadvantages. For v3, the alignment matrix only maps the sky coordinates to instrument coordinates, and all mount-dependent code is isolated in 2 different classes , one for each type of mount. Each class has its own goto, tracking etc. routines. This way we only test the mount type once at startup, and in most cases we no longer need to call isAltAz() or similar functions at run-time.","title":"Alignment, Equatorial vs AltAz mounts"},{"location":"teenastro_v3/#mapping-sky-coordinates-to-axis-angles","text":"","title":"Mapping sky coordinates to axis angles"},{"location":"teenastro_v3/#equatorial-mounts","text":"Mapping axis positions to sky coordinates seems simple, but requires careful definitions. For an equatorial mount, Axis1 is the Hour Angle and Axis2 is the Declination. A GEM mount in the Home Position points to the pole, with its DEC axis vertical. From this position, the DEC axis can move either clockwise (as seen from the top), in which case it points towards the geographic east, or counterclockwise, to point to geographic west. Following Mel Bartels, the grand-daddy of telescope mount controllers , we define the home position as Axis2 = zero, the counterclockwise orientation as \"direct\" (Axis2 > 0, Pier Side=East) and the clockwise orientation as \"flipped\" (Axis2 < 0, Pier Side=West). We can now plot the following relations between axes and coordinates, for a GEM mount in the northern hemisphere. For the southern hemisphere, both plots are reversed. Note that equatorial forks are different (to be done). ha_direct = axis1+90, ha_flipped=axis1-90 dec = 90+axis2[-90..0], dec=90-axis2[0..90]","title":"Equatorial Mounts"},{"location":"teenastro_v3/#altaz-mounts","text":"For AltAz mounts, Axis1 is the azimuth and Axis2 is the altitude. Home position is defined as Alt=0, pointing away from the pole (in the Northern hemisphere: az=180\u00ba, alt=0\u00ba, in the Southern Hemisphere, az=0\u00ba, alt=0\u00ba). We define the Axis1 direction as positive for Clockwise, like the azimuth. Azimuth = Axis1 mod 360 Altitude = Axis2","title":"AltAz Mounts"},{"location":"teenastro_v3/#implementation-details","text":"","title":"Implementation Details"},{"location":"teenastro_v3/#hardware-abstraction-layer-hal","text":"The Arduino framework and libraries already provide most of the abstraction layer (UART, SPI etc.), but some functionality still requires #ifdef in the code. This includes: Chip-specific code chip reset programming hardware timers installing and running interrupt service routines (ISR) non-volatile memory Board-specific code Pin definitions and multiplexing other peripherals on the PCB (real-time clock) Until now, we have been inserting #ifdef statements throughout the code, which is not very readable or portable. A better solution would be an abstraction layer that encapsulates all chip and board-specific code like this: HAL.h #ifdef BOARD_240 // the current TeenAstro board #include teensy_3_2.h #include board_240.h #endif #ifdef BOARD_250 // TiNico's Teensy 4 board #include teensy_4_0.h #include board_250.h #endif #ifdef BOARD_ESP32 // John's ESP32 board #include esp32_s3.h #include board_esp32.h #endif teensy_3_2.h #define ISR(f) void f(void) void beginTimers(void) { ... } esp32_s3.h #define ISR(f) void IRAM_ATTR f(void) hw_timer_t *timerP = NULL; void beginTimers(void) { ... }","title":"Hardware Abstraction Layer (HAL)"},{"location":"teenastro_v3/#timers","text":"The ISR running off the sidereal timer has only one purpose, which is to update the sidereal time. All other tasks run at multiples of the operating system's tick, normally one millisecond.","title":"Timers"},{"location":"teenastro_v3/#non-volatile-memory","text":"On ESP32 there is no EEPROM, but a section of RAM that emulates EEPROM, and gets written into the Flash with the EEPROM.commit() function. To keep the code compatible, the Monitor task performs a hash of the RAM (every 10 seconds or so) and commits it to Flash when a change is detected.","title":"Non-Volatile Memory"},{"location":"teenastro_v3/#motion-control-spi-only-mode-of-the-5160-stepper-controller","text":"The TeenAstrov2 code base uses the STEP/DIR mode for controlling the stepper motor driver (TMC2130 or TMC5160). This requires the microcontroller to toggle the STEP input of the driver for each step. Since we use microstepping to get a smooth motion, we program one interrupt for each microstep. The interrupt period is t = 24 * 3600 / (gear reduction * steps/rot * microsteps) For example, for a gear reduction of 1000 (ratio of motor axis to mount axis rotations), typical motors with 200 steps/rotation, 32 microsteps, and sidereal rate (one mount axis rotation for 24 hours), our interrupt period is: t = 24 * 3600 / (1000 * 200 * 32) = 13.5mS. At higher slew speeds, the interrupt period is reduced proportionally: at a slew speed of 100x, the period is 13.5mS / 100 = 135\u00b5S. In turn, the minimum interrupt period of the microcontroller limits the maximum slew speed. (to 675x in our example for the Teensy 3.2). The corresponding step size for the motor axis is 360\u00ba / (gear reduction * steps/rot * microsteps). In our example, the step size is 360 / (1000 * 200 * 32) = 0.000056\u00ba = 0.2\" (arc-seconds). This step size should be kept as low as possible to ensure smooth tracking and guiding. The Trinamic 5160 can run without STEP/DIR interrupts and can control the motor directly through the SPI without requiring a microcontroller interrupt at each step. Therefore we can use the highest possible microstep value (128) and the highest slew rate that the motors can handle. (We are only limited by the maximum torque).","title":"Motion Control (SPI-only) mode of the 5160 stepper controller"},{"location":"teenastro_v3/#motor-api","text":"All the motor functionality is accessed through this API. The device driver for each type of motor (Step/Dir, MotionControl, Servo) implements these functions. class MotionControl { public: virtual void init(void); virtual void setCurrentPos(long); virtual void setTargetPos(long); virtual void setVmax(double); virtual void setAmax(long); virtual long getCurrentPos(void); virtual long getTargetPos(void); virtual double getSpeed(void); virtual bool positionReached(void); virtual bool isSlewing(void); virtual void adjustSpeed(double); };","title":"Motor API"},{"location":"teenastro_v3/#hardware","text":"For the SPI-only mode, we need the 5160 BOB (Breakout Board), not the 5160 SilentStepStick, for 2 reasons: set SD_MODE to GND to use the internal step generator connect an external clock to the CLK input. Without this external clock, the precision is +-4%, obviously unusable in our case","title":"Hardware"}]}